// @ts-nocheck
import React, { useState, useRef, useEffect, useCallback } from "react";
import { useTranslation } from "react-i18next";
import { Bot, Trash2, Send, Settings, BarChart3, Brain, Clock, Target, Activity, Zap, Globe, BookOpen, Lightbulb, MapPin, Save, RotateCcw, Share2, Download, Copy, Database, Users, TrendingUp, CheckCircle, AlertCircle } from "lucide-react";
import { useGuruloMemory } from '../hooks/memory/useGuruloMemory';
import {
  enhanceWithMemory,
  addGeorgianSignature,
  type GuruloFormattedMessage
} from '../utils/georgianChatFormatter';
// üéØ PHASE 1: Enhanced Message Renderer Integration
import MessageRenderer from './MessageRenderer';
// üá¨üá™ PHASE 4: Georgian Support Integration
import { useGeorgianSupport, type GeorgianSupportConfig } from '../utils/georgianSupport';
// Added AIServiceStatus component for AI service status indication
import AIServiceStatus from './AIServiceStatus';
// Import useAsyncAction hook for managing async actions with loading and error states
import { useAsyncAction } from '../hooks/useAsyncAction';
// Import attachments, feedback API, DiffCard, and ErrorCard
import { useAttachments } from '../hooks/useAttachments';
import { feedbackApi } from '../services/feedbackApi';
import { DiffCard, DiffItem } from './Chat/DiffCard';
import { ErrorCard } from './Shared/ErrorCard';
//SOL-391: Import ActivityTimeline  
import ActivityTimeline from './Chat/Activity/ActivityTimeline';
import type { ActivityPayload } from '../types/activity';


// ===== ENHANCED CHAT MESSAGE INTERFACE =====
interface ChatMessage {
  id: string;
  type: "user" | "ai";
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  // üé® Georgian formatting enhancements
  formatted?: GuruloFormattedMessage;
  memoryIntegrated?: boolean;
  contextAware?: boolean;
  // Error handling context for retry functionality
  errorContext?: {
    originalInput: string;
    errorType: string;
    canRetry: boolean;
    suggestions: string[];
    originalError: string;
  };
  // Attachments for user messages
  attachments?: Array<{ id: string; name: string; path: string; contentType: string; url?: string; size?: number }>;
  // For regenerating messages
  regenerated?: boolean;
  // Metadata for diff cards
  meta?: {
    diffs?: DiffItem[];
    activity?: ActivityPayload['activity']; // Add activity to meta
  };
}

// ===== PHASE 5: PROFESSIONAL FEATURES INTERFACES =====

// üîÑ Checkpoint System
interface Checkpoint {
  id: string;
  name: string;
  description: string;
  timestamp: Date;
  sessionId: string;
  messages: ChatMessage[];
  metadata: {
    userTriggered: boolean;
    autoGenerated: boolean;
    version: string;
    context: string[];
  };
}

// üìä Performance Analytics
interface PerformanceMetrics {
  responseTime: number;
  tokenEfficiency: number;
  accuracyScore: number;
  userSatisfaction: number;
  memoryUsage: number;
  cacheHitRate: number;
  sessionDuration: number;
  messageQuality: number;
  contextRelevance: number;
  georgianLanguageScore: number;
}

// ü§ù Collaboration Features
interface CollaborationData {
  sessionSharing: {
    sharedSessions: string[];
    sharedWith: string[];
    accessLevel: 'read' | 'write' | 'admin';
  };
  knowledgeBase: {
    savedSnippets: CodeSnippet[];
    commonSolutions: Solution[];
    teamLearnings: Learning[];
  };
  teamMetrics: {
    sharedProblems: number;
    resolvedIssues: number;
    knowledgeContributions: number;
  };
}

interface CodeSnippet {
  id: string;
  title: string;
  code: string;
  language: string;
  description: string;
  tags: string[];
  author: string;
  timestamp: Date;
  usage: number;
}

interface Solution {
  id: string;
  problem: string;
  solution: string;
  code?: string;
  effectiveness: number;
  votes: number;
  author: string;
  timestamp: Date;
}

interface Learning {
  id: string;
  topic: string;
  insights: string;
  examples: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  georgianTerms: string[];
  timestamp: Date;
}

// ===== ENHANCED CHAT SESSION INTERFACE =====
interface ChatSession {
  id: string;
  title: string;
  messages: ChatMessage[];
  timestamp: Date;
  lastActivity: Date;
  messageCount: number;
  isArchived?: boolean;
  // PHASE 5: Professional enhancements
  checkpoints: Checkpoint[];
  performance: PerformanceMetrics;
  collaboration: CollaborationData;
  quality: {
    avgResponseTime: number;
    accuracy: number;
    satisfaction: number;
    georgianSupport: number;
  };
  tags: string[];
  favorite: boolean;
}

// ===== CHAT PANEL PROPS =====
interface ChatPanelProps {
  currentFile: { path: string; content: string } | null;
  authUser: any;
  aiFetch: (endpoint: string, options?: RequestInit) => Promise<any>;
  setRequestInspector: React.Dispatch<React.SetStateAction<any>>;
  setConsoleLogs: React.Dispatch<React.SetStateAction<any>>;
  // SOL-212: Replit Assistant Mode Props
  assistantMode: 'basic' | 'advanced';
  setAssistantMode: React.Dispatch<React.SetStateAction<'basic' | 'advanced'>>;
  fileContext: string[];
  setFileContext: React.Dispatch<React.SetStateAction<string[]>>;
  showEditPreview: boolean;
  setShowEditPreview: React.Dispatch<React.SetStateAction<boolean>>;
  pendingEditRequest: any;
  setPendingEditRequest: React.Dispatch<React.SetStateAction<any>>;
}

// Define Message interface for chat input component (if separate)
interface Message {
  id: string;
  text: string;
  sender: 'user' | 'ai';
  timestamp: Date;
  attachments?: Array<{ id: string; name: string; path: string; contentType: string; url?: string; size?: number }>;
  regenerated?: boolean;
  meta?: {
    diffs?: DiffItem[];
  };
}

// Define Input state type
interface ChatInputState {
  text: string;
  attachments: Array<{ id: string; name: string; url?: string; }>;
}

export default function ChatPanel({
  currentFile,
  authUser,
  aiFetch,
  setRequestInspector,
  setConsoleLogs,
  assistantMode,
  setAssistantMode,
  fileContext,
  setFileContext,
  showEditPreview,
  setShowEditPreview,
  pendingEditRequest,
  setPendingEditRequest
}: ChatPanelProps) {
  // Unused props for future functionality - kept as per spec
  void currentFile;
  void setRequestInspector;
  void setConsoleLogs;

  const { t } = useTranslation();

  // ===== CHATSESSION STATE =====
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  // State for chat messages managed by the input component
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState(""); // State for the current input message
  const [loading, setLoading] = useState(false); // loading is now managed by useAsyncAction

  // ===== GURULO MEMORY INTEGRATION =====
  const {
    interactions,
    preferences,
    rememberInteraction,
    updateContext,
    getMemoryStats,
    getWebSocketStatus,
    connectWebSocket
  } = useGuruloMemory();

  // ===== CHAT STATE =====
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  // const [chatInput, setChatInput] = useState(""); // Replaced by 'message' state

  // ===== GEORGIAN FORMATTING STATE =====
  const [memoryStats, setMemoryStats] = useState(getMemoryStats());

  // üá¨üá™ PHASE 4: Georgian Support State
  const georgianSupport = useGeorgianSupport();
  const [georgianConfig, setGeorgianConfig] = useState<Partial<GeorgianSupportConfig>>({
    enabled: true,
    languageEnhancement: {
      autoCorrection: true,
      transliteration: true,
      mixedLanguageFormatting: true,
      georgianCodeComments: true
    },
    culturalAdaptation: {
      georgianTerminology: true,
      localExamples: true,
      georgianErrors: true,
      regionalContext: true
    },
    userPreferences: {
      explanationLevel: 'intermediate',
      preferredTranslationStyle: 'explanatory',
      showTerminologyHelp: true,
      enableCulturalContext: true,
      complexityLevel: 'intermediate'
    },
    ui: {
      showGeorgianControls: true,
      enableLanguageToggle: true,
      showCapabilities: true,
      enableQuickActions: true
    }
  });
  const [showGeorgianControls, setShowGeorgianControls] = useState(false);

  // ===== SOL-203: ENHANCED CONTROLS =====
  const [showControls, setShowControls] = useState(false);
  const [modelSelection, setModelSelection] = useState<'llama-3.1-8b-instant' | 'llama-3.1-70b-versatile'>('llama-3.1-8b-instant');
  const [streamingEnabled, setStreamingEnabled] = useState(false);
  const [contextDepth, setContextDepth] = useState(3); // 1-5 scale
  const [languageMode, setLanguageMode] = useState<'ka' | 'en' | 'mixed'>('ka');

  // ===== TELEMETRY STATE =====
  const [telemetry, setTelemetry] = useState({
    tokenUsage: { prompt: 0, completion: 0, total: 0 },
    responseLatency: 0,
    successRate: 100,
    modelEfficiency: 85,
    intentClassification: '',
    contextSize: 0,
    memoryCacheHits: 0
  });

  // ===== PHASE 5: PROFESSIONAL FEATURES STATE =====

  // üîÑ Checkpoint System State
  const [checkpoints, setCheckpoints] = useState<Checkpoint[]>([]);
  const [showCheckpointPanel, setShowCheckpointPanel] = useState(false);
  const [checkpointName, setCheckpointName] = useState('');
  const [autoCheckpointEnabled, setAutoCheckpointEnabled] = useState(true);
  const [lastCheckpointTime, setLastCheckpointTime] = useState<Date | null>(null);

  // üìä Performance Analytics State
  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({
    responseTime: 0, tokenEfficiency: 0, accuracyScore: 0, userSatisfaction: 0,
    memoryUsage: 0, cacheHitRate: 0, sessionDuration: 0, messageQuality: 0,
    contextRelevance: 0, georgianLanguageScore: 0
  });
  const [showPerformancePanel, setShowPerformancePanel] = useState(false);
  const [performanceHistory, setPerformanceHistory] = useState<PerformanceMetrics[]>([]);

  // ü§ù Collaboration Features State
  const [collaborationData, setCollaborationData] = useState<CollaborationData>({
    sessionSharing: {
      sharedSessions: [],
      sharedWith: [],
      accessLevel: 'read'
    },
    knowledgeBase: { savedSnippets: [], commonSolutions: [], teamLearnings: [] },
    teamMetrics: {
      sharedProblems: 0, resolvedIssues: 0, knowledgeContributions: 0
    }
  });
  const [showCollaborationPanel, setShowCollaborationPanel] = useState(false);
  const [codeSnippetTitle, setCodeSnippetTitle] = useState('');
  const [shareSessionId, setShareSessionId] = useState('');

  // ===== REPLIT ASSISTANT STATE =====
  const [newFileContext, setNewFileContext] = useState("");
  const [lastUserInput, setLastUserInput] = useState('');
  const { attachments, uploading, uploadFiles, removeAttachment, clearAttachments } = useAttachments();

  // ===== CHAT REF =====
  const chatContainerRef = useRef<HTMLDivElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null); // Ref for scrolling

  // ===== HELPER FUNCTIONS =====
  const generateSessionTitle = (firstMessage: string): string => {
    const maxLength = 30;
    const trimmedMessage = firstMessage.trim();
    return trimmedMessage.length > maxLength
      ? trimmedMessage.substring(0, maxLength) + '...'
      : trimmedMessage || 'Untitled Session';
  };

  const createNewSession = () => {
    const newSession: ChatSession = {
      id: crypto.randomUUID(),
      title: '·Éê·ÉÆ·Éê·Éö·Éò ·É©·Éê·É¢·Éò',
      messages: [],
      timestamp: new Date(),
      lastActivity: new Date(),
      messageCount: 0,
      checkpoints: [], // Initialize checkpoints
      performance: { // Initialize performance metrics
        responseTime: 0, tokenEfficiency: 0, accuracyScore: 0, userSatisfaction: 0,
        memoryUsage: 0, cacheHitRate: 0, sessionDuration: 0, messageQuality: 0,
        contextRelevance: 0, georgianLanguageScore: 0
      },
      collaboration: { // Initialize collaboration data
        sessionSharing: { sharedSessions: [], sharedWith: [], accessLevel: 'read' },
        knowledgeBase: { savedSnippets: [], commonSolutions: [], teamLearnings: [] },
        teamMetrics: { sharedProblems: 0, resolvedIssues: 0, knowledgeContributions: 0 }
      },
      quality: { // Initialize quality metrics
        avgResponseTime: 0, accuracy: 0, satisfaction: 0, georgianSupport: 0
      },
      tags: [],
      favorite: false,
    };
    setChatSessions(prevSessions => [...prevSessions, newSession]);
    setCurrentSessionId(newSession.id);
    setChatMessages([]); // Clear current messages for the new session
    setMessages([]); // Clear messages for the input component as well
  };

  const importSessions = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target?.result as string);
        // Basic validation
        if (Array.isArray(importedData) && importedData.every((item: any) => item.id && item.title && item.messages)) {
          const sessions: ChatSession[] = importedData.map((session: any) => ({
            ...session,
            timestamp: new Date(session.timestamp),
            lastActivity: new Date(session.lastActivity),
            messages: session.messages.map((msg: any) => ({
              ...msg,
              timestamp: new Date(msg.timestamp).toISOString() // Ensure timestamp is string for storage
            })),
            checkpoints: session.checkpoints || [],
            performance: session.performance || { // Initialize performance metrics
              responseTime: 0, tokenEfficiency: 0, accuracyScore: 0, userSatisfaction: 0,
              memoryUsage: 0, cacheHitRate: 0, sessionDuration: 0, messageQuality: 0,
              contextRelevance: 0, georgianLanguageScore: 0
            },
            collaboration: session.collaboration || { // Initialize collaboration data
              sessionSharing: { sharedSessions: [], sharedWith: [], accessLevel: 'read' },
              knowledgeBase: { savedSnippets: [], commonSolutions: [], teamLearnings: [] },
              teamMetrics: { sharedProblems: 0, resolvedIssues: 0, knowledgeContributions: 0 }
            },
            quality: session.quality || { // Initialize quality metrics
              avgResponseTime: 0, accuracy: 0, satisfaction: 0, georgianSupport: 0
            },
          }));
          setChatSessions(prev => [...prev, ...sessions]);
          alert(`${sessions.length} sessions imported successfully!`);
        } else {
          alert('Invalid file format. Please upload a valid JSON array of chat sessions.');
        }
      } catch (error) {
        console.error('Failed to import sessions:', error);
        alert('Error importing sessions. Please check the file.');
      }
    };
    reader.readAsText(file);
  };

  const exportSession = (sessionId: string) => {
    const sessionToExport = chatSessions.find(s => s.id === sessionId);
    if (!sessionToExport) return;

    const blob = new Blob([JSON.stringify(sessionToExport, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${sessionToExport.title.replace(/\s+/g, '_')}_${sessionToExport.timestamp.toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const duplicateSession = (sessionId: string) => {
    const sessionToDuplicate = chatSessions.find(s => s.id === sessionId);
    if (!sessionToDuplicate) return;

    const newSession: ChatSession = {
      ...sessionToDuplicate,
      id: crypto.randomUUID(),
      title: `${sessionToDuplicate.title} (Copy)`,
      timestamp: new Date(),
      lastActivity: new Date(),
      messages: sessionToDuplicate.messages.map(msg => ({ ...msg, id: crypto.randomUUID() })), // Ensure unique message IDs
    };
    setChatSessions(prev => [...prev, newSession]);
  };

  const archiveSession = (sessionId: string) => {
    setChatSessions(prev => prev.map(s =>
      s.id === sessionId ? { ...s, isArchived: true } : s
    ));
  };

  const deleteSession = (sessionId: string) => {
    setChatSessions(prev => prev.filter(s => s.id !== sessionId));
    if (currentSessionId === sessionId) {
      setCurrentSessionId(null);
      setChatMessages([]);
      setMessages([]); // Also clear messages for the input component
    }
  };

  // ===== PHASE 5: PROFESSIONAL FEATURES FUNCTIONS =====

  // üîÑ CHECKPOINT SYSTEM FUNCTIONS
  const createCheckpoint = (name?: string, description?: string, userTriggered = false) => {
    if (!currentSessionId) return;

    const checkpoint: Checkpoint = {
      id: crypto.randomUUID(),
      name: name || `Auto-Checkpoint ${new Date().toLocaleTimeString()}`,
      description: description || `Automatic checkpoint created at ${new Date().toLocaleString()}`,
      timestamp: new Date(),
      sessionId: currentSessionId,
      messages: [...chatMessages],
      metadata: {
        userTriggered,
        autoGenerated: !userTriggered,
        version: '1.0.0',
        context: fileContext
      }
    };

    setCheckpoints(prev => [...prev, checkpoint]);
    setLastCheckpointTime(new Date());

    // Update session with checkpoint
    setChatSessions(prev => prev.map(session =>
      session.id === currentSessionId
        ? {
          ...session,
          checkpoints: [...(session.checkpoints || []), checkpoint]
        }
        : session
    ));

    // Store in localStorage
    // localStorage.setItem('gurulo_checkpoints', JSON.stringify([...checkpoints, checkpoint])); // This is handled by the useEffect below

    return checkpoint;
  };

  const createManualCheckpoint = () => {
    if (!checkpointName.trim()) {
      alert('·Éí·Éó·ÉÆ·Éù·Éï·Éó ·Éõ·Éò·É£·Éó·Éò·Éó·Éù·Éó checkpoint-·Éò·É° ·É°·Éê·ÉÆ·Éî·Éö·Éò');
      return;
    }

    const checkpoint = createCheckpoint(
      checkpointName,
      `Manual checkpoint: ${checkpointName}`,
      true
    );

    if (checkpoint) {
      setCheckpointName('');
      alert(`‚úÖ Checkpoint "${checkpoint.name}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·É®·Éî·Éò·É•·Éõ·Éú·Éê!`);
    }
  };

  const rollbackToCheckpoint = (checkpointId: string) => {
    const checkpoint = checkpoints.find(cp => cp.id === checkpointId);
    if (!checkpoint) {
      alert('Checkpoint ·Éï·Éî·É† ·Éõ·Éù·Éò·É´·Éî·Éë·Éú·Éê');
      return;
    }

    const confirmed = window.confirm(
      `·Éì·Éê·É†·É¨·Éõ·É£·Éú·Éî·Éë·É£·Éö·Éò ·ÉÆ·Éê·É†·Éó ·É†·Éù·Éõ ·Éí·É°·É£·É†·Éó ·Éì·Éê·Éë·É†·É£·Éú·Éî·Éë·Éê checkpoint-·Éñ·Éî "${checkpoint.name}"?\n\n·Éî·É°·Éî ·Éß·Éï·Éî·Éö·Éê ·É®·Éî·Éõ·Éì·Éî·Éí·Éò message ·É¨·Éê·Éò·É®·Éö·Éî·Éë·Éê.`
    );

    if (confirmed) {
      setChatMessages(checkpoint.messages);
      setMessages(checkpoint.messages.map(msg => ({ // Update input messages as well
        text: msg.content, sender: msg.type === 'user' ? 'user' : 'ai', timestamp: new Date(msg.timestamp)
      })));

      // Create rollback checkpoint before applying
      createCheckpoint(
        `Rollback to ${checkpoint.name}`,
        `Rolled back from ${chatMessages.length} messages to ${checkpoint.messages.length} messages`,
        true
      );

      alert(`‚úÖ ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éï·Éë·É†·É£·Éú·Éì·Éò·Éó checkpoint-·Éñ·Éî "${checkpoint.name}"`);
    }
  };

  const deleteCheckpoint = (checkpointId: string) => {
    const checkpoint = checkpoints.find(cp => cp.id === checkpointId);
    if (!checkpoint) return;

    const confirmed = window.confirm(`·Éí·É°·É£·É†·Éó checkpoint "${checkpoint.name}"-·Éò·É° ·É¨·Éê·É®·Éö·Éê?`);
    if (confirmed) {
      setCheckpoints(prev => prev.filter(cp => cp.id !== checkpointId));
      // localStorage.setItem('gurulo_checkpoints', JSON.stringify(checkpoints.filter(cp => cp.id !== checkpointId))); // Handled by useEffect
    }
  };

  // üìä PERFORMANCE ANALYTICS FUNCTIONS
  const updatePerformanceMetrics = (responseData: any, responseTime: number) => {
    const newMetrics: PerformanceMetrics = {
      responseTime,
      tokenEfficiency: responseData.usage?.total_tokens ? (responseData.response?.length || 0) / responseData.usage.total_tokens : 0,
      accuracyScore: calculateAccuracyScore(responseData.response),
      userSatisfaction: calculateUserSatisfaction(),
      memoryUsage: getMemoryUsage(),
      cacheHitRate: memoryStats.cacheHitRate || 0,
      sessionDuration: Date.now() - (new Date(chatSessions.find(s => s.id === currentSessionId)?.timestamp || new Date()).getTime()),
      messageQuality: calculateMessageQuality(responseData.response),
      contextRelevance: calculateContextRelevance(responseData.response),
      georgianLanguageScore: calculateGeorgianLanguageScore(responseData.response)
    };

    setPerformanceMetrics(newMetrics);
    setPerformanceHistory(prev => [...prev.slice(-19), newMetrics]); // Keep last 20 entries

    // Update telemetry with real data
    setTelemetry(prev => ({
      ...prev,
      responseLatency: responseTime,
      tokenUsage: responseData.usage || prev.tokenUsage,
      modelEfficiency: Math.round(newMetrics.tokenEfficiency * 100),
      successRate: calculateSuccessRate(),
      contextSize: fileContext.length,
      memoryCacheHits: memoryStats.interactions || 0
    }));
  };

  const calculateAccuracyScore = (response: string): number => {
    // Georgian language bonus
    const georgianBonus = /[·Éê-·É∞]/.test(response) ? 10 : 0;
    // Code block bonus
    const codeBonus = response.includes('```') ? 15 : 0;
    // Length appropriateness
    const lengthScore = response.length > 50 && response.length < 2000 ? 20 : 10;
    // Emoji and formatting bonus
    const formattingBonus = /[üîßüìãüí°‚ö°üéØ‚úÖ‚ùå‚ö†Ô∏è]/.test(response) ? 10 : 0;

    return Math.min(100, 45 + georgianBonus + codeBonus + lengthScore + formattingBonus);
  };

  const calculateUserSatisfaction = (): number => {
    const recentMessages = chatMessages.slice(-10);
    const userMessages = recentMessages.filter(m => m.type === 'user').length;
    const aiMessages = recentMessages.filter(m => m.type === 'ai').length;

    // Good conversation flow = balanced messages
    const balanceScore = userMessages > 0 && aiMessages > 0 ? 50 : 20;
    // Session length bonus
    const lengthBonus = Math.min(30, chatMessages.length * 2);
    // Memory integration bonus
    const memoryBonus = recentMessages.some(m => m.memoryIntegrated) ? 20 : 0;

    return Math.min(100, balanceScore + lengthBonus + memoryBonus);
  };

  const calculateMessageQuality = (response: string): number => {
    let score = 40; // Base score

    // Georgian text quality
    if (/[·Éê-·É∞]/.test(response)) score += 20;
    // Code examples
    if (response.includes('```')) score += 15;
    // Structured content
    if (response.includes('##') || response.includes('###')) score += 10;
    // Emoji usage
    if (/[üîßüìãüí°‚ö°üéØ]/.test(response)) score += 10;
    // Appropriate length
    if (response.length > 100 && response.length < 1500) score += 5;

    return Math.min(100, score);
  };

  const calculateContextRelevance = (response: string): number => {
    let relevanceScore = 50; // Base score

    // File context relevance
    if (fileContext.length > 0) {
      const contextWords = fileContext.join(' ').toLowerCase();
      const responseWords = response.toLowerCase();
      const matches = contextWords.split(' ').filter(word =>
        word.length > 3 && responseWords.includes(word)
      ).length;
      relevanceScore += Math.min(30, matches * 5);
    }

    // Mode relevance
    if (assistantMode === 'advanced' && response.includes('edit')) relevanceScore += 10;
    if (assistantMode === 'basic' && !response.includes('edit')) relevanceScore += 10;

    return Math.min(100, relevanceScore);
  };

  const calculateGeorgianLanguageScore = (response: string): number => {
    let score = 0;

    // Georgian text presence
    const georgianMatches = response.match(/[·Éê-·É∞]/g);
    if (georgianMatches) {
      score += Math.min(40, georgianMatches.length / 5);
    }

    // Mixed language quality
    const hasEnglish = /[a-zA-Z]/.test(response);
    const hasGeorgian = /[·Éê-·É∞]/.test(response);
    if (hasEnglish && hasGeorgian) score += 20;

    // Georgian programming terms
    const georgianTerms = ['·Éû·É†·Éù·Éí·É†·Éê·Éõ·Éò·É†·Éî·Éë·Éê', '·Éô·Éù·Éì·Éò', '·É§·É£·Éú·É•·É™·Éò·Éê', '·É™·Éï·Éö·Éê·Éì·Éò', '·Éõ·Éê·É°·Éò·Éï·Éò'];
    georgianTerms.forEach(term => {
      if (response.includes(term)) score += 10;
    });

    return Math.min(100, score);
  };

  const calculateSuccessRate = (): number => {
    const recentMessages = chatMessages.slice(-20);
    const aiMessages = recentMessages.filter(m => m.type === 'ai');
    const successfulMessages = aiMessages.filter(m =>
      m.content.length > 50 && !m.content.toLowerCase().includes('error')
    );

    return aiMessages.length > 0 ? Math.round((successfulMessages.length / aiMessages.length) * 100) : 100;
  };

  const getMemoryUsage = (): number => {
    // Simulate memory usage calculation
    const sessionSize = JSON.stringify(chatMessages).length;
    const checkpointSize = JSON.stringify(checkpoints).length;
    const totalSize = sessionSize + checkpointSize;

    // Convert to percentage (max 100MB simulated)
    return Math.min(100, (totalSize / (100 * 1024 * 1024)) * 100);
  };

  // ü§ù COLLABORATION FEATURES FUNCTIONS
  const shareSession = (sessionId: string) => {
    const session = chatSessions.find(s => s.id === sessionId);
    if (!session) {
      alert('Session ·Éï·Éî·É† ·Éõ·Éù·Éò·É´·Éî·Éë·Éú·Éê');
      return;
    }

    const shareData = {
      id: session.id,
      title: session.title,
      messages: session.messages,
      timestamp: session.timestamp,
      sharedBy: authUser?.personalId || 'anonymous',
      sharedAt: new Date()
    };

    // Copy to clipboard
    navigator.clipboard.writeText(JSON.stringify(shareData, null, 2)).then(() => {
      alert(`‚úÖ Session "${session.title}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éô·Éù·Éû·Éò·É†·Éì·Éê clipboard-·É®·Éò!\n\n·Éí·Éê·É£·Éñ·Éò·Éê·É†·Éî·Éó team member-·Éî·Éë·É°.`);

      // Update collaboration data
      setCollaborationData(prev => ({
        ...prev,
        sessionSharing: {
          ...prev.sessionSharing,
          sharedSessions: [...prev.sessionSharing.sharedSessions, sessionId]
        },
        teamMetrics: {
          ...prev.teamMetrics,
          sharedProblems: prev.teamMetrics.sharedProblems + 1
        }
      }));
    }).catch(() => {
      alert('·Éô·Éù·Éû·Éò·É†·Éî·Éë·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê');
    });
  };

  const exportCodeSnippet = (code: string, language: string = 'typescript') => {
    if (!codeSnippetTitle.trim()) {
      alert('·Éí·Éó·ÉÆ·Éù·Éï·Éó ·Éõ·Éò·É£·Éó·Éò·Éó·Éù·Éó code snippet-·Éò·É° ·É°·Éê·Éó·Éê·É£·É†·Éò');
      return;
    }

    const snippet: CodeSnippet = {
      id: crypto.randomUUID(),
      title: codeSnippetTitle,
      code,
      language,
      description: `Exported from Gurulo AI session: ${chatSessions.find(s => s.id === currentSessionId)?.title || 'Unknown'}`,
      tags: ['gurulo-ai', 'exported', language],
      author: authUser?.personalId || 'anonymous',
      timestamp: new Date(),
      usage: 0
    };

    // Add to knowledge base
    setCollaborationData(prev => ({
      ...prev,
      knowledgeBase: {
        ...prev.knowledgeBase,
        savedSnippets: [...prev.knowledgeBase.savedSnippets, snippet]
      },
      teamMetrics: {
        ...prev.teamMetrics,
        knowledgeContributions: prev.teamMetrics.knowledgeContributions + 1
      }
    }));

    // Export as file
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${codeSnippetTitle.replace(/\s+/g, '_')}.${getFileExtension(language)}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setCodeSnippetTitle('');
    alert(`‚úÖ Code snippet "${snippet.title}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éí·Éê·Éì·Éê·Éõ·Éù·É¢·Éê·Éú·Éò·Éö·Éò ·Éì·Éê knowledge base-·É®·Éò ·Éì·Éê·Éõ·Éê·É¢·Éî·Éë·É£·Éö·Éò!`);
  };

  const getFileExtension = (language: string): string => {
    const extensions: Record<string, string> = {
      'typescript': 'ts',
      'javascript': 'js',
      'python': 'py',
      'java': 'java',
      'css': 'css',
      'html': 'html',
      'json': 'json',
      'sql': 'sql'
    };
    return extensions[language] || 'txt';
  };

  const addToKnowledgeBase = (problem: string, solution: string, code?: string) => {
    const newSolution: Solution = {
      id: crypto.randomUUID(),
      problem,
      solution,
      code,
      effectiveness: 85, // Default rating
      votes: 1,
      author: authUser?.personalId || 'anonymous',
      timestamp: new Date()
    };

    setCollaborationData(prev => ({
      ...prev,
      knowledgeBase: {
        ...prev.knowledgeBase,
        commonSolutions: [...prev.knowledgeBase.commonSolutions, newSolution]
      },
      teamMetrics: {
        ...prev.teamMetrics,
        resolvedIssues: prev.teamMetrics.resolvedIssues + 1
      }
    }));

    alert('‚úÖ ·Éê·ÉÆ·Éê·Éö·Éò ·Éí·Éê·Éì·Éê·É¨·Éß·Éï·Éî·É¢·Éê ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éî·Éõ·Éê·É¢·Éê Knowledge Base-·É®·Éò!');
  };

  // ===== PHASE 2: CHAT SESSIONS MANAGEMENT =====

  // Load chat sessions from localStorage on mount
  useEffect(() => {
    const savedSessions = localStorage.getItem('gurulo_chat_sessions');
    if (savedSessions) {
      try {
        const sessions = JSON.parse(savedSessions).map((session: any) => ({
          ...session,
          timestamp: new Date(session.timestamp),
          lastActivity: new Date(session.lastActivity),
          messages: session.messages.map((msg: any) => ({ // Ensure messages are properly deserialized
            ...msg,
            timestamp: new Date(msg.timestamp)
          })),
          checkpoints: session.checkpoints || [], // Load checkpoints
          performance: session.performance || { // Load performance metrics
            responseTime: 0, tokenEfficiency: 0, accuracyScore: 0, userSatisfaction: 0,
            memoryUsage: 0, cacheHitRate: 0, sessionDuration: 0, messageQuality: 0,
            contextRelevance: 0, georgianLanguageScore: 0
          },
          collaboration: session.collaboration || { // Load collaboration data
            sessionSharing: { sharedSessions: [], sharedWith: [], accessLevel: 'read' },
            knowledgeBase: { savedSnippets: [], commonSolutions: [], teamLearnings: [] },
            teamMetrics: { sharedProblems: 0, resolvedIssues: 0, knowledgeContributions: 0 }
          },
          quality: session.quality || { // Load quality metrics
            avgResponseTime: 0, accuracy: 0, satisfaction: 0, georgianSupport: 0
          },
        }));
        setChatSessions(sessions);

        // Load the most recent session if no current session is set
        if (sessions.length > 0 && !currentSessionId) {
          const mostRecent = sessions.sort((a: ChatSession, b: ChatSession) =>
            b.lastActivity.getTime() - a.lastActivity.getTime()
          )[0];
          setCurrentSessionId(mostRecent.id);
          setChatMessages(mostRecent.messages || []);
          setMessages(mostRecent.messages.map(msg => ({ // Set messages for input component
            text: msg.content, sender: msg.type === 'user' ? 'user' : 'ai', timestamp: new Date(msg.timestamp)
          })));
        } else if (sessions.length === 0) {
          // Create initial session if storage was empty or invalid
          createNewSession();
        }
      } catch (error) {
        console.error('Failed to load chat sessions:', error);
        // Create initial session if loading fails
        createNewSession();
      }
    } else {
      // Create initial session if none exists
      createNewSession();
    }
  }, []);

  // Save chat sessions to localStorage whenever they change
  useEffect(() => {
    // Filter out archived sessions before saving if desired, or keep them
    const sessionsToSave = chatSessions.map(session => ({
      ...session,
      // Ensure dates are serialized correctly for JSON storage
      timestamp: session.timestamp.toISOString(),
      lastActivity: session.lastActivity.toISOString(),
      messages: session.messages.map(msg => ({
        ...msg,
        // Ensure message timestamps are strings for storage
        timestamp: msg.timestamp,
      })),
      // Ensure checkpoints, performance, and collaboration data are also saved correctly
      checkpoints: session.checkpoints.map(cp => ({
        ...cp,
        timestamp: cp.timestamp.toISOString()
      })),
      performance: {
        ...session.performance,
        // No date fields in performance metrics to serialize
      },
      collaboration: {
        ...session.collaboration,
        knowledgeBase: {
          ...session.collaboration.knowledgeBase,
          savedSnippets: session.collaboration.knowledgeBase.savedSnippets.map(snippet => ({
            ...snippet,
            timestamp: snippet.timestamp.toISOString()
          })),
          commonSolutions: session.collaboration.knowledgeBase.commonSolutions.map(solution => ({
            ...solution,
            timestamp: solution.timestamp.toISOString()
          })),
          teamLearnings: session.collaboration.knowledgeBase.teamLearnings.map(learning => ({
            ...learning,
            timestamp: learning.timestamp.toISOString()
          }))
        }
      }
    }));
    localStorage.setItem('gurulo_chat_sessions', JSON.stringify(sessionsToSave));
  }, [chatSessions]);

  // Update current session messages when chatMessages change
  useEffect(() => {
    if (currentSessionId && chatMessages.length > 0) {
      setChatSessions(prev => prev.map(session =>
        session.id === currentSessionId
          ? {
            ...session,
            messages: chatMessages,
            messageCount: chatMessages.length,
            lastActivity: new Date(),
            // Auto-generate title from first user message if it's a new session title
            title: session.title === '·Éê·ÉÆ·Éê·Éö·Éò ·É©·Éê·É¢·Éò' && chatMessages.length > 0
              ? generateSessionTitle(chatMessages[0]?.content || '')
              : session.title
          }
          : session
      ));
    } else if (currentSessionId && chatMessages.length === 0) {
      // If current session messages are cleared, update the session record
      setChatSessions(prev => prev.map(session =>
        session.id === currentSessionId ? { ...session, messageCount: 0, lastActivity: new Date() }
          : session
      ));
    }
  }, [chatMessages, currentSessionId]);

  // ===== GURULO MEMORY EFFECTS =====
  useEffect(() => {
    // Update memory stats periodically
    const updateStats = () => setMemoryStats(getMemoryStats());
    const interval = setInterval(updateStats, 30000);
    return () => clearInterval(interval);
  }, [getMemoryStats]);

  useEffect(() => {
    // Connect WebSocket and update project context
    connectWebSocket();
    updateContext(
      'Bakhmaro Cottages Platform',
      'Chat ·É°·Éò·É°·É¢·Éî·Éõ·Éò·É° ·Éí·Éê·Éú·Éï·Éò·Éó·Éê·É†·Éî·Éë·Éê',
      fileContext
    );
  }, [connectWebSocket, updateContext, fileContext]);

  // ===== PHASE 5: PROFESSIONAL FEATURES DATA PERSISTENCE =====

  // üîÑ Load checkpoints from localStorage
  useEffect(() => {
    const savedCheckpoints = localStorage.getItem('gurulo_checkpoints');
    if (savedCheckpoints) {
      try {
        const checkpoints = JSON.parse(savedCheckpoints).map((cp: any) => ({
          ...cp,
          timestamp: new Date(cp.timestamp)
        }));
        setCheckpoints(checkpoints);
      } catch (error) {
        console.error('Failed to load checkpoints:', error);
      }
    }
  }, []);

  // üìä Load performance history from localStorage
  useEffect(() => {
    const savedPerformance = localStorage.getItem('gurulo_performance_history');
    if (savedPerformance) {
      try {
        const performanceData = JSON.parse(savedPerformance);
        setPerformanceHistory(performanceData);
      } catch (error) {
        console.error('Failed to load performance history:', error);
      }
    }
  }, []);

  // ü§ù Load collaboration data from localStorage
  useEffect(() => {
    const savedCollaboration = localStorage.getItem('gurulo_collaboration_data');
    if (savedCollaboration) {
      try {
        const collaborationData = JSON.parse(savedCollaboration);
        setCollaborationData(prev => ({
          ...prev,
          ...collaborationData,
          knowledgeBase: {
            ...prev.knowledgeBase,
            ...collaborationData.knowledgeBase,
            savedSnippets: collaborationData.knowledgeBase?.savedSnippets?.map((snippet: any) => ({
              ...snippet,
              timestamp: new Date(snippet.timestamp)
            })) || [],
            commonSolutions: collaborationData.knowledgeBase?.commonSolutions?.map((solution: any) => ({
              ...solution,
              timestamp: new Date(solution.timestamp)
            })) || [],
            teamLearnings: collaborationData.knowledgeBase?.teamLearnings?.map((learning: any) => ({
              ...learning,
              timestamp: new Date(learning.timestamp)
            })) || []
          }
        }));
      } catch (error) {
        console.error('Failed to load collaboration data:', error);
      }
    }
  }, []);

  // üîÑ Save checkpoints to localStorage whenever they change
  useEffect(() => {
    if (checkpoints.length > 0) {
      localStorage.setItem('gurulo_checkpoints', JSON.stringify(checkpoints.map(cp => ({
        ...cp,
        timestamp: cp.timestamp.toISOString()
      }))));
    }
  }, [checkpoints]);

  // üìä Save performance history to localStorage
  useEffect(() => {
    if (performanceHistory.length > 0) {
      localStorage.setItem('gurulo_performance_history', JSON.stringify(performanceHistory));
    }
  }, [performanceHistory]);

  // ü§ù Save collaboration data to localStorage
  useEffect(() => {
    localStorage.setItem('gurulo_collaboration_data', JSON.stringify({
      ...collaborationData,
      knowledgeBase: {
        ...collaborationData.knowledgeBase,
        savedSnippets: collaborationData.knowledgeBase.savedSnippets.map(snippet => ({
          ...snippet,
          timestamp: snippet.timestamp.toISOString()
        })),
        commonSolutions: collaborationData.knowledgeBase.commonSolutions.map(solution => ({
          ...solution,
          timestamp: solution.timestamp.toISOString()
        })),
        teamLearnings: collaborationData.knowledgeBase.teamLearnings.map(learning => ({
          ...learning,
          timestamp: learning.timestamp.toISOString()
        }))
      }
    }));
  }, [collaborationData]);

  // Scroll to bottom when messages change
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages]); // Depend on 'messages' state for input component


  // ===== RETRY FUNCTIONALITY =====
  const retryMessage = async (originalInput: string, errorContext?: any) => {
    if (!originalInput || originalInput.trim().length === 0) {
      alert('·Éê·É† ·Éõ·Éù·Éò·É´·Éî·Éë·Éú·Éê ·Éó·Éê·Éï·Éì·Éê·Éû·Éò·É†·Éï·Éî·Éö·Éò ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê retry-·É°·Éó·Éï·Éò·É°');
      return;
    }

    // Remove the error message before retrying
    setMessages(prev => prev.slice(0, -1));

    // Set the input back to original message
    setInput(originalInput);

    // Slight delay to ensure UI updates
    setTimeout(() => {
      // Use the new onSendClick handler to send the message
      onSendClick();
    }, 100);
  };

  // ===== ENHANCED CHAT FUNCTIONS WITH PROFESSIONAL FEATURES =====
  // Refactored sendMessage to use useCallback and useAsyncAction
  const sendMessageAction = useCallback(async (messageText: string, messageAttachments?: ChatMessage['attachments']) => {
    if (!messageText.trim() || !authUser?.personalId) return; // Use authUser.personalId

    const userMessage: ChatMessage = { // Create ChatMessage for display
      id: Date.now().toString(),
      type: "user",
      content: messageText,
      timestamp: new Date().toISOString(),
      memoryIntegrated: false,
      contextAware: false,
      attachments: messageAttachments,
    };

    setChatMessages(prev => [...prev, userMessage]); // Add to main chat display

    // Payload for the AI API
    const requestPayload = {
      message: messageText,
      personalId: authUser.personalId, // Use authUser.personalId
      mode: assistantMode,
      fileContext: fileContext,
      attachments: messageAttachments, // Include attachments in the payload
      context: {
        isAdvanced: assistantMode === 'advanced',
        requestType: assistantMode === 'advanced' ? 'edit_request' : 'basic_query',
        currentFile: currentFile?.path || null
      }
    };

    // Validate payload before sending
    if (assistantMode === 'advanced' && !requestPayload.context.currentFile && fileContext.length === 0) {
      throw new Error('·É§·Éê·Éò·Éö·Éò·É° ·Éõ·Éì·Éî·Éë·Éê·É†·Éî·Éù·Éë·Éê (filePath) ·Éê·É† ·Éê·É†·Éò·É° ·Éõ·Éò·Éó·Éò·Éó·Éî·Éë·É£·Éö·Éò. Advanced ·É†·Éî·Éü·Éò·Éõ·É®·Éò ·É°·Éê·É≠·Éò·É†·Éù·Éê ·É§·Éê·Éò·Éö·Éò·É° ·Éô·Éù·Éú·É¢·Éî·É•·É°·É¢·Éò.');
    }

    // üìä PHASE 5: Start performance tracking
    const startTime = Date.now();

    const response = await aiFetch("chat", {
      method: "POST",
      body: JSON.stringify(requestPayload),
    });

    // Validate response data
    if (!response) {
      throw new Error('AI ·É°·Éî·É†·Éï·Éò·É°·Éò·É°·Éí·Éê·Éú ·Éû·Éê·É°·É£·ÉÆ·Éò ·Éê·É† ·Éõ·Éò·Éò·É¶·Éî·Éë·Éê. ·É°·É™·Éê·Éì·Éî·Éó ·Éô·Éï·Éö·Éê·Éï.');
    }

    if (response.error) {
      // Normalize the error to a readable string once so we can safely inspect it
      const responseError = typeof response.error === 'string'
        ? response.error
        : JSON.stringify(response.error);

      // Handle specific API errors
      if (responseError.includes('filePath')) {
        throw new Error('·É§·Éê·Éò·Éö·Éò·É° ·Éõ·Éì·Éî·Éë·Éê·É†·Éî·Éù·Éë·Éê (filePath) ·Éê·É† ·Éê·É†·Éò·É° ·É°·É¨·Éù·É†·Éê·Éì ·Éõ·Éò·Éó·Éò·Éó·Éî·Éë·É£·Éö·Éò. ·É®·Éî·Éê·Éõ·Éù·É¨·Éõ·Éî·Éó ·É§·Éê·Éò·Éö·Éò·É° ·Éô·Éù·Éú·É¢·Éî·É•·É°·É¢·Éò.');
      } else if (responseError.toLowerCase().includes('timeout')) {
        throw new Error('AI ·É°·Éî·É†·Éï·Éò·É°·Éò ·Éú·Éî·Éö·Éê ·Éû·Éê·É°·É£·ÉÆ·Éù·Éë·É°. ·Éì·Éê·Éî·Éö·Éù·Éì·Éî·Éó ·Éì·Éê ·É°·É™·Éê·Éì·Éî·Éó ·Éô·Éï·Éö·Éê·Éï.');
      } else if (responseError.toLowerCase().includes('rate limit')) {
        throw new Error('·É´·Éê·Éö·Éò·Éê·Éú ·Éë·Éî·Éï·É†·Éò ·Éõ·Éù·Éó·ÉÆ·Éù·Éï·Éú·Éê. ·Éí·Éó·ÉÆ·Éù·Éï·Éó, ·Éì·Éê·Éî·Éö·Éù·Éì·Éù·Éó 1-2 ·É¨·É£·Éó·É°.');
      } else {
        throw new Error(`AI ·É°·Éî·É†·Éï·Éò·É°·Éò·É° ·É®·Éî·É™·Éì·Éù·Éõ·Éê: ${responseError}`);
      }
    }

    // üìä PHASE 5: Calculate response time
    const responseTime = Date.now() - startTime;

    // Handle Advanced mode edit requests
    if (response.editRequest && assistantMode === 'advanced') {
      setPendingEditRequest(response.editRequest);
      setShowEditPreview(true);

      const editMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        type: "ai",
        content: `üîß **Edit Request Created**\n\n${response.response}\n\n‚ö†Ô∏è *Review the changes below and approve to proceed*`,
        timestamp: new Date().toISOString(),
        memoryIntegrated: true,
        contextAware: true,
        meta: { diffs: response.editRequest.diffs }, // Include diffs for DiffCard
      };
      setChatMessages(prev => [...prev, editMessage]);

      // üß† Record interaction for advanced edit flow
      rememberInteraction(
        messageText,
        response.response,
        `Context: ${fileContext.join(', ')}, Mode: advanced, EditRequest: ${response.editRequest?.type || 'unknown'}`
      );

      // üìä PHASE 5: Update performance metrics for edit requests
      updatePerformanceMetrics({
        response: response.response,
        usage: response.usage || { total_tokens: 0 }
      }, responseTime);

      // üîÑ PHASE 5: Auto-checkpoint for edit requests
      if (autoCheckpointEnabled) {
        createCheckpoint(
          `Edit Request: ${response.editRequest?.type || 'Unknown'}`,
          `Auto-checkpoint before edit request: ${messageText.substring(0, 50)}...`,
          false
        );
      }

    } else {
      // üá¨üá™ PHASE 4: Enhanced Georgian processing with full support
      const baseResponse = response.response || "Sorry, I encountered an error.";

      // Process with Georgian Support system
      const georgianProcessedResponse = georgianSupport.processMessage(
        baseResponse,
        {
          ...preferences,
          ...georgianConfig.userPreferences,
          explanationLevel: georgianConfig.userPreferences?.explanationLevel || 'intermediate',
          enableGeorgianFeatures: georgianConfig.enabled,
          enableCulturalAdaptation: georgianConfig.culturalAdaptation?.georgianTerminology,
          enableTerminologyMapping: georgianConfig.culturalAdaptation?.georgianTerminology,
          showTerminologyHelp: georgianConfig.userPreferences?.showTerminologyHelp
        },
        interactions.slice(-5) // Recent interactions for context
      );

      // Legacy formatting for compatibility
      const formattedResponse = georgianProcessedResponse;

      const aiMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        type: "ai",
        content: addGeorgianSignature(formattedResponse.content),
        timestamp: new Date().toISOString(),
        formatted: formattedResponse,
        memoryIntegrated: true,
        contextAware: true,
        //SOL-391: Include activity data in message meta
        meta: {
          activity: response.activity // Assuming response.activity contains the timeline data
        }
      };

      // üß† Record single interaction in Gurulo memory
      rememberInteraction(
        messageText,
        baseResponse,
        `Context: ${fileContext.join(', ')}, Mode: ${assistantMode}`
      );
      setChatMessages(prev => [...prev, aiMessage]);

      // üìä PHASE 5: Update performance metrics for normal responses
      updatePerformanceMetrics({
        response: baseResponse,
        usage: response.usage || { total_tokens: 0 }
      }, responseTime);

      // üîÑ PHASE 5: Auto-checkpoint for successful responses
      if (autoCheckpointEnabled && chatMessages.length > 0 && chatMessages.length % 3 === 0) {
        createCheckpoint(
          `Auto-Checkpoint ${Math.floor(chatMessages.length / 3)}`,
          `Auto-checkpoint after ${chatMessages.length + 2} messages`,
          false
        );
      }

      // ü§ù PHASE 5: Auto-add valuable responses to knowledge base
      if (baseResponse.includes('```') && baseResponse.length > 200) {
        const codeBlocks = baseResponse.match(/```[\w]*\n([\s\S]*?)```/g);
        if (codeBlocks) {
          addToKnowledgeBase(
            messageText,
            baseResponse,
            codeBlocks[0]
          );
        }
      }
    }
    return response; // Return response for useAsyncAction
  }, [
    authUser, assistantMode, fileContext, currentFile?.path, aiFetch,
    rememberInteraction, updatePerformanceMetrics, autoCheckpointEnabled,
    createCheckpoint, georgianSupport, georgianConfig, preferences,
    interactions, setPendingEditRequest, setShowEditPreview, setChatMessages
  ]);

  const { execute: handleSendMessage, isLoading } = useAsyncAction(
    sendMessageAction,
    {
      preventDuplicates: true,
      onError: (error: any) => {
        console.error("Chat error:", error);

        // üìä PHASE 5: Track error response time
        const errorResponseTime = Date.now() - (performanceMetrics.sessionDuration || 0); // Approximation

        // Determine error type and provide user-friendly message
        let userFriendlyMessage = '';
        let suggestions: string[] = [];
        let canRetry = true;
        let errorType = 'unknown';

        if (error.message) {
          if (error.message.includes('filePath') || error.message.includes('·É§·Éê·Éò·Éö·Éò·É° ·Éõ·Éì·Éî·Éë·Éê·É†·Éî·Éù·Éë·Éê')) {
            userFriendlyMessage = '‚ùå ·É§·Éê·Éò·Éö·Éò·É° ·Éõ·Éì·Éî·Éë·Éê·É†·Éî·Éù·Éë·Éê ·Éê·É† ·Éê·É†·Éò·É° ·Éõ·Éò·Éó·Éò·Éó·Éî·Éë·É£·Éö·Éò';
            suggestions = [
              '‚Ä¢ ·Éì·Éê·Éê·Éõ·Éê·É¢·Éî·Éó ·É§·Éê·Éò·Éö·Éî·Éë·Éò File Context ·É°·Éî·É•·É™·Éò·Éê·É®·Éò',
              '‚Ä¢ ·Éê·Éò·É†·É©·Éò·Éî·Éó ·É§·Éê·Éò·Éö·Éò Explorer-·Éì·Éê·Éú',
              '‚Ä¢ ·Éí·Éê·Éì·Éê·Éî·É†·Éó·Éî·Éó Basic ·É†·Éî·Éü·Éò·Éõ·Éñ·Éî ·Éñ·Éù·Éí·Éê·Éì·Éò ·Éô·Éò·Éó·ÉÆ·Éï·Éî·Éë·Éò·É°·Éó·Éï·Éò·É°'
            ];
            errorType = 'missing_file_context';
          } else if (error.message.includes('timeout') || error.message.includes('·Éú·Éî·Éö·Éê ·Éû·Éê·É°·É£·ÉÆ·Éù·Éë·É°')) {
            userFriendlyMessage = '‚è±Ô∏è AI ·É°·Éî·É†·Éï·Éò·É°·Éò ·Éì·É†·Éù·Éî·Éë·Éò·Éó ·Éú·Éî·Éö·Éê ·Éû·Éê·É°·É£·ÉÆ·Éù·Éë·É°';
            suggestions = [
              '‚Ä¢ ·Éì·Éê·Éî·Éö·Éù·Éì·Éî·Éó 10-30 ·É¨·Éê·Éõ·É°',
              '‚Ä¢ ·É®·Éî·Éê·Éõ·É™·Éò·É†·Éî·Éó ·É®·Éî·Éô·Éò·Éó·ÉÆ·Éï·Éò·É° ·É°·Éò·Éí·É†·É´·Éî',
              '‚Ä¢ ·É®·Éî·Éê·Éõ·Éù·É¨·Éõ·Éî·Éó ·Éò·Éú·É¢·Éî·É†·Éú·Éî·É¢ ·Éô·Éê·Éï·É®·Éò·É†·Éò'
            ];
            errorType = 'timeout';
          } else if (error.message.includes('rate limit') || error.message.includes('·Éë·Éî·Éï·É†·Éò ·Éõ·Éù·Éó·ÉÆ·Éù·Éï·Éú·Éê')) {
            userFriendlyMessage = 'üö¶ ·É´·Éê·Éö·Éò·Éê·Éú ·Éë·Éî·Éï·É†·Éò ·Éõ·Éù·Éó·ÉÆ·Éù·Éï·Éú·Éê - ·Éì·É†·Éù·Éî·Éë·Éò·Éó·Éò ·É®·Éî·Éñ·É¶·É£·Éì·Éï·Éê';
            suggestions = [
              '‚Ä¢ ·Éì·Éê·Éî·Éö·Éù·Éì·Éî·Éó 1-2 ·É¨·É£·Éó·É°',
              '‚Ä¢ ·Éê·É† ·Éí·Éê·Éí·Éñ·Éê·Éï·Éú·Éù·Éó ·Éë·Éî·Éï·É†·Éò ·É®·Éî·Éô·Éò·Éó·ÉÆ·Éï·Éê ·Éî·É†·Éó·Éì·É†·Éù·É£·Éö·Éê·Éì'
            ];
            errorType = 'rate_limit';
            canRetry = false; // Don't allow immediate retry for rate limiting

            // Show toast for rate limiting
            window.dispatchEvent(new CustomEvent('ui-error', {
              detail: {
                type: 'network',
                message: userFriendlyMessage,
                severity: 'medium',
                component: 'ChatPanel'
              }
            }));
          } else if (error.message.includes('·É™·Éê·É†·Éò·Éî·Éö·Éò·Éê')) {
            userFriendlyMessage = 'üìù ·É®·Éî·É¢·Éß·Éù·Éë·Éò·Éú·Éî·Éë·Éê ·É™·Éê·É†·Éò·Éî·Éö·Éò·Éê';
            suggestions = [
              '‚Ä¢ ·Éì·Éê·É¨·Éî·É†·Éî·Éó ·Éó·É•·Éï·Éî·Éú·Éò ·Éô·Éò·Éó·ÉÆ·Éï·Éê',
              '‚Ä¢ ·Éõ·Éò·É£·Éó·Éò·Éó·Éî·Éó ·É†·Éê ·Éì·Éê·ÉÆ·Éõ·Éê·É†·Éî·Éë·Éê ·Éí·É≠·Éò·É†·Éì·Éî·Éë·Éê·Éó'
            ];
            errorType = 'empty_message';
          } else if (error.message.includes('Advanced ·É†·Éî·Éü·Éò·Éõ·Éò·É°·Éó·Éï·Éò·É°')) {
            userFriendlyMessage = '‚ö° Advanced ·É†·Éî·Éü·Éò·Éõ·Éò·É°·Éó·Éï·Éò·É° ·É°·Éê·É≠·Éò·É†·Éù·Éê ·É§·Éê·Éò·Éö·Éò·É° ·Éô·Éù·Éú·É¢·Éî·É•·É°·É¢·Éò';
            suggestions = [
              '‚Ä¢ ·Éì·Éê·Éê·Éõ·Éê·É¢·Éî·Éó ·É§·Éê·Éò·Éö·Éî·Éë·Éò File Context-·É®·Éò',
              '‚Ä¢ ·Éê·Éò·É†·É©·Éò·Éî·Éó ·É§·Éê·Éò·Éö·Éò ·É†·Éù·Éõ·Éî·Éö·Éò·É™ ·Éí·É°·É£·É†·Éó ·É†·Éî·Éì·Éê·É•·É¢·Éò·É†·Éî·Éë·Éê',
              '‚Ä¢ ·Éê·Éú ·Éí·Éê·Éì·Éê·Éî·É†·Éó·Éî·Éó Basic ·É†·Éî·Éü·Éò·Éõ·Éñ·Éî'
            ];
            errorType = 'advanced_mode_no_context';
          } else {
            // Generic error handling
            userFriendlyMessage = error.message;
            suggestions = [
              '‚Ä¢ ·É°·É™·Éê·Éì·Éî·Éó ·Éô·Éï·Éö·Éê·Éï ·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·É®·Éò',
              '‚Ä¢ ·É®·Éî·Éê·Éõ·Éù·É¨·Éõ·Éî·Éó ·Éò·Éú·É¢·Éî·É†·Éú·Éî·É¢ ·Éô·Éê·Éï·É®·Éò·É†·Éò',
              '‚Ä¢ ·Éó·É£ ·Éû·É†·Éù·Éë·Éö·Éî·Éõ·Éê ·Éõ·Éî·Éù·É†·Éì·Éî·Éë·Éê, ·Éí·Éê·Éú·Éê·Éê·ÉÆ·Éö·Éî·Éó ·Éí·Éï·Éî·É†·Éì·Éò'
            ];
            errorType = 'generic';
          }
        } else {
          // Fallback for unknown errors
          userFriendlyMessage = '‚ùå AI ·É°·Éî·É†·Éï·Éò·É°·Éó·Éê·Éú ·Éô·Éê·Éï·É®·Éò·É†·Éò·É° ·Éû·É†·Éù·Éë·Éö·Éî·Éõ·Éê';
          suggestions = [
            '‚Ä¢ ·É®·Éî·Éê·Éõ·Éù·É¨·Éõ·Éî·Éó ·Éò·Éú·É¢·Éî·É†·Éú·Éî·É¢ ·Éô·Éê·Éï·É®·Éò·É†·Éò',
            '‚Ä¢ ·É°·É™·Éê·Éì·Éî·Éó ·Éô·Éï·Éö·Éê·Éï ·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·É®·Éò',
            '‚Ä¢ ·Éí·Éê·Éú·Éê·Éê·ÉÆ·Éö·Éî·Éó ·Éí·Éï·Éî·É†·Éì·Éò ·Éó·É£ ·Éû·É†·Éù·Éë·Éö·Éî·Éõ·Éê ·Éõ·Éî·Éù·É†·Éì·Éî·Éë·Éê'
          ];
          errorType = 'connection_error';
        }

        // üá¨üá™ PHASE 4: Georgian error translation with enhanced context
        const translatedError = georgianConfig.culturalAdaptation?.georgianErrors
          ? georgianSupport.translateError(userFriendlyMessage, errorType)
          : userFriendlyMessage;

        // Create comprehensive error message with suggestions
        const fullErrorContent = `${translatedError}\n\n**·É†·Éî·Éô·Éù·Éõ·Éî·Éú·Éì·Éê·É™·Éò·Éî·Éë·Éò:**\n${suggestions.join('\n')}\n\n${canRetry ? 'üîÑ *·Éì·Éê·Éê·Éô·Éö·Éò·Éô·Éî·Éó "·Éô·Éï·Éö·Éê·Éï ·É™·Éì·Éê" ·É¶·Éò·Éö·Éê·Éô·É° ·É•·Éï·Éî·Éõ·Éù·Éó*' : '‚è≥ *·Éí·Éó·ÉÆ·Éù·Éï·Éó ·Éì·Éê·Éî·Éö·Éù·Éì·Éù·Éó ·Éû·É†·Éù·Éë·Éö·Éî·Éõ·Éò·É° ·Éõ·Éù·Éí·Éï·Éê·É†·Éî·Éë·Éê·É°*'}`;

        const errorMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          type: "ai",
          content: fullErrorContent,
          timestamp: new Date().toISOString(),
          // Add error metadata for retry functionality
          errorContext: {
            originalInput: input, // Use input state here
            errorType,
            canRetry,
            suggestions,
            originalError: error.message
          }
        };
        setChatMessages(prev => [...prev, errorMessage]);

        // üìä PHASE 5: Update metrics for error case
        updatePerformanceMetrics({
          response: translatedError,
          usage: { total_tokens: 0 }
        }, errorResponseTime);
      }
    }
  );

  // Handler for the send button click
  const onSendClick = () => {
    if (input.trim()) {
      sendMessageAction(input, attachments.length > 0 ? attachments : undefined); // Pass attachments
      setLastUserInput(input); // Store for regenerate
      setInput('');
      clearAttachments(); // Clear attachments after sending
    }
  };

  const handleClearChat = () => {
    setChatMessages([]);
    setMessages([]); // Clear messages for the input component as well
  };

  // ===== FILE CONTEXT FUNCTIONS =====
  const addFileContext = () => {
    if (newFileContext.trim() && !fileContext.includes(newFileContext.trim())) {
      setFileContext([...fileContext, newFileContext.trim()]);
      setNewFileContext("");
    }
  };

  const removeFileContext = (file: string) => {
    setFileContext(fileContext.filter(f => f !== file));
  };

  // ===== EDIT REQUEST FUNCTIONS =====
  const approveEditRequest = async () => {
    if (pendingEditRequest) {
      try {
        // Simulate approval process
        const approvalMessage: ChatMessage = {
          id: Date.now().toString(),
          type: "ai",
          content: "‚úÖ **Edit Request Approved!**\\n\\nChanges have been applied successfully. Checkpoint created for rollback if needed.",
          timestamp: new Date().toISOString(),
        };
        setChatMessages(prev => [...prev, approvalMessage]);
        setPendingEditRequest(null);
        setShowEditPreview(false);
      } catch (error: any) {
        console.error('Edit approval failed:', error);
      }
    }
  };

  const rejectEditRequest = () => {
    const rejectionMessage: ChatMessage = {
      id: Date.now().toString(),
      type: "ai",
      content: "‚ùå **Edit Request Cancelled**\\n\\nNo changes were made to your files.",
      timestamp: new Date().toISOString(),
    };
    setChatMessages(prev => [...prev, rejectionMessage]);
    setPendingEditRequest(null);
    setShowEditPreview(false);
  };

  // ===== MESSAGE ACTIONS FUNCTIONS =====
  const handleRegenerate = async (messageId: string) => {
    // Find the original user message that prompted this AI response
    const messageIndex = chatMessages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1 || messageIndex === 0) return; // Cannot regenerate if it's the first message or not found

    const userMessage = chatMessages[messageIndex - 1];
    if (!userMessage || userMessage.type !== 'user' || !userMessage.content) return;

    // We are re-sending the original user prompt to regenerate the AI response
    await sendMessageAction(userMessage.content, userMessage.attachments);
  };


  const handleApplyDiff = async (path: string, content: string) => {
    try {
      // Assuming aiFetch can be used for file operations or a dedicated API call
      const response = await aiFetch("/api/files/apply", { // Adjust endpoint as needed
        method: "POST",
        body: JSON.stringify({ path, content })
      });

      if (response.ok) {
        alert(`‚úÖ Successfully applied changes to ${path}`);
        // Optionally, update the UI or chat state to reflect applied changes
        setShowEditPreview(false); // Close preview after applying
      } else {
        alert(`‚ùå Failed to apply changes to ${path}: ${response.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Apply diff error:', error);
      alert('‚ùå An error occurred while applying changes.');
    }
  };


  // ===== RENDER CHAT UI =====
  return (
    <div className="h-full flex flex-col bg-gray-800">
      {/* Header with Mode Selection */}
      <div className="p-4 border-b border-gray-700 bg-gradient-to-r from-gray-800 to-gray-750">
        <div className="flex items-center justify-between mb-3">
          <div className="flex items-center space-x-4">
            <div className="flex items-center">
              <div className="relative">
                <div className="bg-gradient-to-r from-blue-500 to-green-500 p-2 rounded-full">
                  <Bot size={24} className="text-white" />
                </div>
                <div className="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full animate-pulse border-2 border-gray-800 flex items-center justify-center">
                  <div className="w-2 h-2 bg-white rounded-full"></div>
                </div>
              </div>
              <div className="ml-4">
                <h3 className="text-white font-bold text-xl bg-gradient-to-r from-blue-400 to-green-400 bg-clip-text text-transparent">
                  {t("aiDeveloper.assistant", "·Éí·É£·É†·É£·Éö·Éù")}
                </h3>
                <p className="text-sm text-gray-300 font-medium">Advanced Georgian AI Developer</p>
                <p className="text-xs text-gray-500">‚ú® Replit Assistant ·Éì·Éù·Éú·Éî·Éñ·Éî</p>
              </div>
            </div>
            {/* SOL-203: Real-time Telemetry Display */}
            <div className="flex items-center space-x-3 text-xs text-gray-400">
              <div className="flex items-center space-x-1">
                <Target className="w-3 h-3" />
                <span>{telemetry.tokenUsage.total} tokens</span>
              </div>
              <div className="flex items-center space-x-1">
                <Clock className="w-3 h-3" />
                <span>{telemetry.responseLatency}ms</span>
              </div>
              <div className="flex items-center space-x-1">
                <BarChart3 className="w-3 h-3" />
                <span>{telemetry.successRate}%</span>
              </div>
              {telemetry.intentClassification && (
                <div className="flex items-center space-x-1">
                  <Brain className="w-3 h-3" />
                  <span className="text-blue-300">{telemetry.intentClassification}</span>
                </div>
              )}
            </div>
          </div>
          <div className="flex items-center space-x-2">
            {/* üîÑ PHASE 5: Checkpoint System Button */}
            <button
              onClick={() => setShowCheckpointPanel(!showCheckpointPanel)}
              className="text-yellow-400 hover:text-yellow-300 relative"
              title="Checkpoint System"
            >
              <Save size={16} />
              {checkpoints.length > 0 && (
                <span className="absolute -top-1 -right-1 w-3 h-3 bg-yellow-500 text-xs rounded-full flex items-center justify-center text-black font-bold">
                  {checkpoints.length}
                </span>
              )}
            </button>

            {/* üìä PHASE 5: Performance Analytics Button */}
            <button
              onClick={() => setShowPerformancePanel(!showPerformancePanel)}
              className="text-green-400 hover:text-green-300 relative"
              title="Performance Analytics"
            >
              <TrendingUp size={16} />
              <span className="absolute -bottom-1 -right-1 w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
            </button>

            {/* ü§ù PHASE 5: Collaboration Features Button */}
            <button
              onClick={() => setShowCollaborationPanel(!showCollaborationPanel)}
              className="text-blue-400 hover:text-blue-300 relative"
              title="Collaboration Features"
            >
              <Users size={16} />
              {collaborationData.knowledgeBase.savedSnippets.length > 0 && (
                <span className="absolute -top-1 -right-1 w-3 h-3 bg-blue-500 text-xs rounded-full flex items-center justify-center text-white font-bold">
                  {collaborationData.knowledgeBase.savedSnippets.length}
                </span>
              )}
            </button>

            <button
              onClick={() => setShowControls(!showControls)}
              className="text-gray-400 hover:text-white"
              title="AI Controls"
            >
              <Settings size={16} />
            </button>
            <button onClick={handleClearChat} className="text-gray-400 hover:text-white" title="Clear chat">
              <Trash2 size={16} />
            </button>
          </div>
        </div>

        {/* SOL-203: Advanced Controls Panel */}
        {showControls && (
          <div className="mb-3 p-3 bg-gray-700/50 rounded border border-gray-600">
            <div className="text-sm text-gray-300 mb-2">‚öôÔ∏è AI Controls & Telemetry</div>
            <div className="grid grid-cols-2 gap-3 text-xs">
              <div>
                <label className="block text-gray-400 mb-1">üß† Model:</label>
                <select
                  value={modelSelection}
                  onChange={(e) => setModelSelection(e.target.value as any)}
                  className="w-full bg-gray-800 text-gray-200 px-2 py-1 rounded border border-gray-600"
                >
                  <option value="llama-3.1-8b-instant">LLaMA 3.1 8B (Fast)</option>
                  <option value="llama-3.1-70b-versatile">LLaMA 3.1 70B (Smart)</option>
                </select>
              </div>
              <div>
                <label className="block text-gray-400 mb-1">üåç Language:</label>
                <select
                  value={languageMode}
                  onChange={(e) => setLanguageMode(e.target.value as any)}
                  className="w-full bg-gray-800 text-gray-200 px-2 py-1 rounded border border-gray-600"
                >
                  <option value="ka">üá¨üá™ ·É•·Éê·É†·Éó·É£·Éö·Éò</option>
                  <option value="en">üá∫üá∏ English</option>
                  <option value="mixed">üîÑ Mixed</option>
                </select>
              </div>
              <div>
                <label className="flex items-center space-x-2">
                  <input
                    type="checkbox"
                    checked={streamingEnabled}
                    onChange={(e) => setStreamingEnabled(e.target.checked)}
                    className="rounded"
                  />
                  <span className="text-gray-400">‚ö° Streaming</span>
                </label>
              </div>
              <div>
                <label className="block text-gray-400 mb-1">üìä Context: {contextDepth}/5</label>
                <input
                  type="range"
                  min="1"
                  max="5"
                  value={contextDepth}
                  onChange={(e) => setContextDepth(parseInt(e.target.value))}
                  className="w-full"
                />
              </div>
            </div>
          </div>
        )}

        {/* üîÑ PHASE 5: CHECKPOINT SYSTEM PANEL */}
        {showCheckpointPanel && (
          <div className="mb-3 p-3 bg-yellow-900/20 rounded border border-yellow-600/30">
            <div className="text-sm text-yellow-300 mb-3 flex items-center justify-between">
              <span>üîÑ Checkpoint System</span>
              <div className="flex items-center space-x-2">
                <label className="flex items-center space-x-1 text-xs">
                  <input
                    type="checkbox"
                    checked={autoCheckpointEnabled}
                    onChange={(e) => setAutoCheckpointEnabled(e.target.checked)}
                  />
                  <span>Auto-checkpoints</span>
                </label>
                {lastCheckpointTime && (
                  <span className="text-xs text-yellow-400">
                    Last: {lastCheckpointTime.toLocaleTimeString()}
                  </span>
                )}
              </div>
            </div>

            {/* Manual Checkpoint Creation */}
            <div className="mb-3 flex space-x-2">
              <input
                type="text"
                value={checkpointName}
                onChange={(e) => setCheckpointName(e.target.value)}
                placeholder="Checkpoint name..."
                className="flex-1 bg-gray-800 text-gray-200 px-2 py-1 rounded text-xs border border-gray-600"
              />
              <button
                onClick={createManualCheckpoint}
                disabled={!checkpointName.trim()}
                className="px-2 py-1 bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-600 text-white rounded text-xs"
              >
                <Save size={12} />
              </button>
            </div>

            {/* Checkpoint List */}
            <div className="max-h-32 overflow-y-auto space-y-1">
              {checkpoints.slice(-5).reverse().map((checkpoint) => (
                <div key={checkpoint.id} className="flex items-center justify-between bg-gray-800/50 p-2 rounded text-xs">
                  <div className="flex-1">
                    <div className="text-yellow-300 font-medium">{checkpoint.name}</div>
                    <div className="text-gray-400 text-xs">
                      {checkpoint.timestamp.toLocaleString()} ‚Ä¢ {checkpoint.messages.length} messages
                    </div>
                  </div>
                  <div className="flex space-x-1">
                    <button
                      onClick={() => rollbackToCheckpoint(checkpoint.id)}
                      className="text-green-400 hover:text-green-300"
                      title="Rollback"
                    >
                      <RotateCcw size={12} />
                    </button>
                    <button
                      onClick={() => deleteCheckpoint(checkpoint.id)}
                      className="text-red-400 hover:text-red-300"
                      title="Delete"
                    >
                      <Trash2 size={12} />
                    </button>
                  </div>
                </div>
              ))}
              {checkpoints.length === 0 && (
                <div className="text-gray-500 text-xs italic">No checkpoints yet</div>
              )}
            </div>
          </div>
        )}

        {/* üìä PHASE 5: PERFORMANCE ANALYTICS PANEL */}
        {showPerformancePanel && (
          <div className="mb-3 p-3 bg-green-900/20 rounded border border-green-600/30">
            <div className="text-sm text-green-300 mb-3">üìä Performance Analytics</div>

            <div className="grid grid-cols-3 gap-2 text-xs">
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Response Time</div>
                <div className="text-green-300 font-bold">{performanceMetrics.responseTime}ms</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Accuracy</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.accuracyScore)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">User Satisfaction</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.userSatisfaction)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Token Efficiency</div>
                <div className="text-green-300 font-bold">{(performanceMetrics.tokenEfficiency * 100).toFixed(1)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Georgian Score</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.georgianLanguageScore)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Memory Usage</div>
                <div className="text-green-300 font-bold">{performanceMetrics.memoryUsage.toFixed(1)}%</div>
              </div>
            </div>

            {/* Session Quality Metrics */}
            <div className="mt-2 p-2 bg-gray-800/30 rounded">
              <div className="text-xs text-gray-400 mb-1">Session Quality Overview</div>
              <div className="flex space-x-3 text-xs">
                <span className="text-blue-300">Messages: {chatMessages.length}</span>
                <span className="text-yellow-300">Avg Response: {telemetry.responseLatency}ms</span>
                <span className="text-green-300">Success Rate: {telemetry.successRate}%</span>
                <span className="text-purple-300">Context: {telemetry.contextSize} files</span>
              </div>
            </div>
          </div>
        )}

        {/* ü§ù PHASE 5: COLLABORATION FEATURES PANEL */}
        {showCollaborationPanel && (
          <div className="mb-3 p-3 bg-blue-900/20 rounded border border-blue-600/30">
            <div className="text-sm text-blue-300 mb-3">ü§ù Collaboration Features</div>

            {/* Session Sharing */}
            <div className="mb-3">
              <div className="text-xs text-gray-400 mb-1">Session Sharing</div>
              <div className="flex space-x-2">
                <button
                  onClick={() => currentSessionId && shareSession(currentSessionId)}
                  disabled={!currentSessionId}
                  className="px-2 py-1 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 text-white rounded text-xs flex items-center space-x-1"
                >
                  <Share2 size={12} />
                  <span>Share Session</span>
                </button>
                <span className="text-xs text-gray-500 flex items-center">
                  Shared: {collaborationData.teamMetrics.sharedProblems}
                </span>
              </div>
            </div>

            {/* Code Snippet Export */}
            <div className="mb-3">
              <div className="text-xs text-gray-400 mb-1">Code Snippet Export</div>
              <div className="flex space-x-2">
                <input
                  type="text"
                  value={codeSnippetTitle}
                  onChange={(e) => setCodeSnippetTitle(e.target.value)}
                  placeholder="Snippet title..."
                  className="flex-1 bg-gray-800 text-gray-200 px-2 py-1 rounded text-xs border border-gray-600"
                />
                <button
                  onClick={() => {
                    const lastMessage = chatMessages.slice().reverse().find(m => m.type === 'ai' && m.content.includes('```'));
                    if (lastMessage) {
                      const codeMatch = lastMessage.content.match(/```[\w]*\n([\s\S]*?)```/);
                      if (codeMatch) {
                        exportCodeSnippet(codeMatch[1], 'typescript');
                      }
                    }
                  }}
                  disabled={!codeSnippetTitle.trim()}
                  className="px-2 py-1 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 text-white rounded text-xs flex items-center space-x-1"
                >
                  <Download size={12} />
                  <span>Export</span>
                </button>
              </div>
            </div>

            {/* Knowledge Base Stats */}
            <div className="grid grid-cols-3 gap-2 text-xs">
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.knowledgeBase.savedSnippets.length}</div>
                <div className="text-gray-400">Snippets</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.knowledgeBase.commonSolutions.length}</div>
                <div className="text-gray-400">Solutions</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.teamMetrics.knowledgeContributions}</div>
                <div className="text-gray-400">Contributions</div>
              </div>
            </div>

            {/* Recent Knowledge Base Items */}
            {collaborationData.knowledgeBase.savedSnippets.length > 0 && (
              <div className="mt-2">
                <div className="text-xs text-gray-400 mb-1">Recent Snippets</div>
                <div className="max-h-20 overflow-y-auto space-y-1">
                  {collaborationData.knowledgeBase.savedSnippets.slice(-3).reverse().map((snippet) => (
                    <div key={snippet.id} className="bg-gray-800/30 p-1 rounded text-xs">
                      <div className="text-blue-300">{snippet.title}</div>
                      <div className="text-gray-500">{snippet.language} ‚Ä¢ {snippet.timestamp.toLocaleDateString()}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Replit Assistant Mode Selection */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm text-gray-400">üéõÔ∏è Mode:</span>
            <button
              onClick={() => setAssistantMode('basic')}
              className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                assistantMode === 'basic'
                  ? 'bg-green-600 text-white'
                  : 'bg-gray-600 text-gray-300 hover:bg-gray-500'
              }`}
            >
              üÜì Basic
            </button>
            <button
              onClick={() => setAssistantMode('advanced')}
              className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                assistantMode === 'advanced'
                  ? 'bg-orange-600 text-white'
                  : 'bg-gray-600 text-gray-300 hover:bg-gray-500'
              }`}
            >
              ‚ö° Advanced
            </button>
          </div>
          <div className="text-xs text-gray-500">
            {assistantMode === 'basic' ? '·Éê·ÉÆ·É°·Éú·Éê/·É†·Éî·Éô·Éù·Éõ·Éî·Éú·Éì·Éê·É™·Éò·Éî·Éë·Éò' : '·Éô·Éù·Éì·Éò·É° ·É†·Éî·Éì·Éê·É•·É¢·Éò·É†·Éî·Éë·Éê'}
          </div>
        </div>
      </div>

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* File Context Section */}
        {fileContext.length > 0 && (
          <div className="p-3 border-b border-gray-700 bg-gray-750">
            <div className="text-xs text-gray-400 mb-2">üìé File Context:</div>
            <div className="flex flex-wrap gap-1">
              {fileContext.map((file) => (
                <div key={file} className="flex items-center bg-blue-600 text-white px-2 py-1 rounded text-xs">
                  <span>{file}</span>
                  <button
                    onClick={() => removeFileContext(file)}
                    className="ml-1 text-blue-200 hover:text-white"
                  >
                    √ó
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Edit Preview Modal */}
        {showEditPreview && pendingEditRequest && (
          <div className="p-3 border-b border-gray-700 bg-orange-900">
            <div className="text-sm text-orange-200 mb-2">üîß Edit Request Preview</div>
            <div className="bg-gray-800 p-2 rounded text-xs text-gray-300 mb-3">
              <pre className="whitespace-pre-wrap">{pendingEditRequest.preview || 'Preview generating...'}</pre>
            </div>
            <div className="flex gap-2">
              <button
                onClick={approveEditRequest}
                className="px-3 py-1 bg-green-600 text-white rounded text-xs hover:bg-green-700"
              >
                ‚úÖ Apply Changes
              </button>
              <button
                onClick={rejectEditRequest}
                className="px-3 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
              >
                ‚ùå Cancel
              </button>
            </div>
          </div>
        )}

        {/* AI Service Status */}
        <div className="px-4 pt-4">
          <AIServiceStatus onStatusChange={(status) => {
            if (status === 'offline') {
              // Handle offline status, e.g., disable input or show message
            }
          }} />
        </div>

        {/* üéØ PHASE 1: Enhanced Message Rendering with Georgian Support */}
        <div className="flex-1 overflow-y-auto p-4" ref={chatContainerRef}>
          {chatMessages.map((message, idx) => {
            // Parse activity from message meta or JSON fenced block
            const activity = (message.meta as ActivityPayload | undefined)?.activity
              ?? (() => {
                const m = /```json[\s\S]*?"activity"\s*:\s*(\[[\s\S]*?\])[\s\S]*?```/i.exec(message.content || '');
                if (!m) return undefined;
                try { return JSON.parse(m[1]); } catch { return undefined; }
              })();

            return (
              <div key={message.id}>
                {/* Show ActivityTimeline for AI messages with activity */}
                {message.type === 'ai' && Array.isArray(activity) && activity.length > 0 && (
                  <ActivityTimeline items={activity} />
                )}
                <MessageRenderer
                  content={message.content}
                  type={message.type}
                  timestamp={message.timestamp}
                  isStreaming={message.isStreaming}
                  formatted={message.formatted}
                  memoryIntegrated={message.memoryIntegrated}
                  contextAware={message.contextAware}
                />
              </div>
            );
          })}
          {/* Enhanced Loading Indicator with MessageRenderer styling */}
          {isLoading && (
            <MessageRenderer
              content="ü§ñ ·Éí·É£·É†·É£·Éö·Éù ·É§·Éò·É•·É†·Éù·Éë·É° ·Éì·Éê ·Éó·É•·Éï·Éî·Éú·Éò ·Éô·Éò·Éó·ÉÆ·Éï·Éò·É° ·Éê·Éú·Éê·Éö·Éò·Éñ·É° ·Éê·ÉÆ·Éù·É†·É™·Éò·Éî·Éö·Éî·Éë·É°..."
              type="ai"
              timestamp={new Date().toISOString()}
              isStreaming={true}
            />
          )}
          {/* Ref for scrolling to the bottom */}
          <div ref={messagesEndRef} />
        </div>

        <div className="p-4 border-t border-gray-700">
          {/* File Context Input */}
          <div className="mb-3 p-2 bg-gray-750 rounded border border-gray-600">
            <div className="text-xs text-gray-400 mb-2">üìé Add File Context (Replit-style):</div>
            <div className="flex gap-2">
              <input
                type="text"
                value={newFileContext}
                onChange={(e) => setNewFileContext(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && addFileContext()}
                placeholder="File path (e.g., src/App.tsx)"
                className="flex-1 bg-gray-700 text-gray-200 px-2 py-1 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <button
                onClick={addFileContext}
                className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
              >
                ‚ûï
              </button>
            </div>
          </div>

          {/* Main Chat Input */}
          <div className="space-y-2">
            {/* Attachments display */}
            {attachments.length > 0 && (
              <div className="flex flex-wrap gap-2 p-2 bg-gray-700 rounded-lg">
                {attachments.map(att => (
                  <div key={att.id} className="flex items-center gap-1 px-2 py-1 bg-gray-600 rounded text-xs">
                    <span>üìé {att.name}</span>
                    <button onClick={() => removeAttachment(att.id)} className="text-red-400 hover:text-red-300">√ó</button>
                  </div>
                ))}
              </div>
            )}

            <div className="flex gap-2">
              <input
                type="file"
                multiple
                onChange={(e) => e.target.files && uploadFiles(e.target.files)}
                className="hidden"
                ref={(el) => (window as any).fileInput = el} // Type assertion for 'fileInput'
              />
              <button
                onClick={() => (window as any).fileInput?.click()}
                disabled={uploading}
                className="px-3 py-2 border border-gray-600 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-blue-500"
                title="Attach files"
              >
                üìé
              </button>
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && onSendClick()}
                placeholder={`Ask Gurulo AI... (${assistantMode.toUpperCase()} mode)`}
                className="flex-1 bg-gray-700 text-gray-200 px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                disabled={isLoading || uploading}
              />
              <button
                onClick={onSendClick}
                disabled={isLoading || uploading || !input.trim()}
                className={`px-4 py-2 rounded-md transition-colors ${
                  isLoading || uploading || !input.trim()
                    ? 'bg-gray-600 cursor-not-allowed text-gray-300'
                    : assistantMode === 'advanced'
                      ? 'bg-orange-600 hover:bg-orange-700 text-white'
                      : 'bg-blue-600 hover:bg-blue-700 text-white'
                }`}
              >
                {isLoading ? 'üì§ Sending...' : uploading ? 'Uploading...' : 'Send'}
              </button>
            </div>
          </div>

          {/* Mode Status */}
          <div className="mt-2 text-xs text-gray-500 text-center">
            {assistantMode === 'advanced' && (
              <span className="text-orange-400">‚ö° Advanced Mode: Code editing with diff preview</span>
            )}
            {assistantMode === 'basic' && (
              <span className="text-green-400">üü¢ Basic Mode: Explanations and recommendations</span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}