require('dotenv').config({ path: './.env' });
const express = require('express');
const cors = require('cors');
const session = require('express-session');
const app = express();

// Add fetch for Node.js if not available
if (!global.fetch) {
  const fetch = require('node-fetch');
  global.fetch = fetch;
}
áƒ°áƒ°áƒ°áƒ°
app.use(cors({
  origin: [
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'http://0.0.0.0:3000',
    process.env.FRONTEND_URL,
    /\.replit\.dev$/,
    /\.repl\.co$/
  ],
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Session configuration for pending operations
app.use(session({
  secret: process.env.SESSION_SECRET || 'bakhmaro-ai-session-key',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: false, // Set to true in production with HTTPS
    maxAge: 30 * 60 * 1000 // 30 minutes
  }
}));

app.get("/", (req, res) => {
  res.send("âœ… AI Backend is running");
});

// Health endpoint for system monitoring
app.get('/health', (req, res) => {
  console.log('ğŸ¥ Backend health check accessed');
  res.status(200).json({
    service: 'Backend Service',
    status: 'healthy',
    timestamp: new Date().toISOString(),
    port: process.env.PORT || 5002,
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Routes
const fileTreeRoute = require('./routes/file_tree');
const fileSaveRoute = require('./routes/file_save');
const aiProxyRoute = require('./routes/ai_proxy');
const notificationsRoute = require('./routes/notifications');
const messagingRoute = require('./routes/messaging');
const commissionRoute = require('./routes/commission');
const projectStatsRoute = require('./routes/project_stats');
const performanceRoute = require('./routes/performance_routes');
const developerPanelRoute = require('./routes/developer_panel');
const healthRoute = require('./routes/health');

// Use Routes
app.use('/api/health', healthRoute);
app.use('/api/files', fileTreeRoute);
app.use('/api/files', fileSaveRoute);
app.use('/api/ai', aiProxyRoute);
app.use('/api/notifications', notificationsRoute);
app.use('/api/messaging', messagingRoute);
app.use('/api/commission', commissionRoute);
app.use('/api/stats', projectStatsRoute);
app.use('/api/performance', performanceRoute);
app.use('/api/developer', developerPanelRoute);
console.log('ğŸ“ File tree routes registered at /api/files');
app.use('/api/developer', require('./routes/developer_panel'));
app.use('/api/ai', require('./routes/ai_proxy'));

// Proxy AI service routes for file system operations
app.use('/api/fs', (req, res) => {
  const aiServiceUrl = process.env.AI_SERVICE_URL || 'http://localhost:5001';
  const url = `${aiServiceUrl}${req.originalUrl}`;

  fetch(url, {
    method: req.method,
    headers: {
      'Content-Type': 'application/json',
      ...req.headers
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
  })
  .then(response => response.json())
  .then(data => res.json(data))
  .catch(error => {
    console.error('AI service proxy error:', error);
    res.status(500).json({ error: 'AI service unavailable' });
  });
});

// Proxy AI chat routes
app.use('/api/ai', (req, res) => {
  const aiServiceUrl = process.env.AI_SERVICE_URL || 'http://localhost:5001';
  const url = `${aiServiceUrl}${req.originalUrl}`;

  fetch(url, {
    method: req.method,
    headers: {
      'Content-Type': 'application/json',
      ...req.headers
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
  })
  .then(response => response.json())
  .then(data => res.json(data))
  .catch(error => {
    console.error('AI service proxy error:', error);
    res.status(500).json({ error: 'AI service unavailable' });
  });
});

// AI Proxy routes (AI now runs as microservice) - Using proper proxy middleware
const { createProxyMiddleware } = require('http-proxy-middleware');

const aiServiceUrl = process.env.AI_SERVICE_URL || 'http://0.0.0.0:5001';
console.log(`ğŸ”§ [Backend] AI Service URL configured: ${aiServiceUrl}`);

app.use('/api/ai', createProxyMiddleware({
  target: aiServiceUrl,
  changeOrigin: true,
  pathRewrite: {
    '^/api/ai': '/api/ai'  // Keep the path structure consistent
  },
  onProxyReq(proxyReq, req, res) {
    console.log(`ğŸ”„ [AI Proxy] Proxying: ${req.method} ${req.originalUrl} -> ${aiServiceUrl}${req.originalUrl}`);
  },
  onProxyRes(proxyRes, req, res) {
    console.log(`âœ… [AI Proxy] Response: ${proxyRes.statusCode} for ${req.method} ${req.originalUrl}`);
  },
  onError(err, req, res) {
    console.error(`âŒ [AI Proxy] Error for ${req.method} ${req.originalUrl}:`, err.message);
    res.status(503).json({
      error: 'AI Service Unavailable',
      message: 'The AI microservice is currently unavailable. Please try again later.',
      timestamp: new Date().toISOString(),
      originalPath: req.originalUrl
    });
  }
}));

console.log('ğŸ”„ [Server] AI proxy middleware registered successfully');

// Security system routes
// The following direct AI routes are removed to ensure all requests go through the proxy
// app.post('/api/ai/dryrun', DryRunController.previewChanges);
// app.get('/api/ai/file-info/:filePath(*)', DryRunController.getFileInfo);

// app.post('/api/ai/submit-approval', ApprovalController.submitForApproval);
// app.get('/api/ai/pending-changes', ApprovalController.getPendingChanges);
// app.post('/api/ai/approve/:changeId', ApprovalController.approveChange);
// app.post('/api/ai/reject/:changeId', ApprovalController.rejectChange);

// app.get('/api/ai/backups/:filePath(*)', RollbackController.getFileBackups);
// app.post('/api/ai/rollback/:filePath(*)', RollbackController.rollbackFile);
// app.get('/api/ai/rollback-history', RollbackController.getRollbackHistory);

// Global error handler
app.use((error, req, res, next) => {
  console.error('ğŸš¨ [Global Error Handler] Unhandled error:', error);
  res.status(500).json({
    error: 'Internal Server Error',
    message: error.message,
    timestamp: new Date().toISOString()
  });
});

const PORT = process.env.PORT || 5002;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`ğŸš€ Backend running on http://0.0.0.0:${PORT}`);

  // Test AI service connection with better error handling
  setTimeout(async () => {
    try {
      const fetch = (await import('node-fetch')).default;
      const aiServiceUrl = process.env.AI_SERVICE_URL || 'http://0.0.0.0:5001';
      console.log(`ğŸ”§ [Backend] Testing AI Service at: ${aiServiceUrl}/health`);

      const response = await fetch(`${aiServiceUrl}/health`, {
        timeout: 5000,
        headers: { 'User-Agent': 'Backend-Health-Check' }
      });

      if (response.ok) {
        const data = await response.json();
        console.log('âœ… AI Service connection verified:', data.service, 'on port', data.port);
      } else {
        console.warn('âš ï¸ AI Service health check failed:', response.status, response.statusText);
      }
    } catch (error) {
      console.warn('âš ï¸ AI Service not available - this is normal during startup:', error.code || error.message);
    }
  }, 3000); // Give AI service time to start

// Backend-specific initialization
console.log('âœ… Backend initialization completed');
  console.log(`ğŸ“¡ AI Chat endpoint available at: /api/ai/chat`);
  console.log(`ğŸ¤– AI Health endpoint: http://0.0.0.0:${PORT}/api/ai/health`);
});

// Test route
app.get('/test', (req, res) => {
  res.json({ message: 'Backend is running!' });
});