import React, { useState, useRef, useEffect } from "react";
import { Bot, Trash2, Send, Settings, BarChart3, Brain, Clock, Target, Activity, Zap, Globe, BookOpen, Lightbulb, MapPin, Save, RotateCcw, Share2, Download, Copy, Database, Users, TrendingUp, CheckCircle, AlertCircle } from "lucide-react";
import { useGuruloMemory } from '../hooks/memory/useGuruloMemory';
import { 
  enhanceWithMemory, 
  addGeorgianSignature,
  type GuruloFormattedMessage 
} from '../utils/georgianChatFormatter';
// üéØ PHASE 1: Enhanced Message Renderer Integration
import MessageRenderer from './MessageRenderer';
// üá¨üá™ PHASE 4: Georgian Support Integration
import { useGeorgianSupport, type GeorgianSupportConfig } from '../utils/georgianSupport';

// ===== ENHANCED CHAT MESSAGE INTERFACE =====
interface ChatMessage {
  id: string;
  type: "user" | "ai";
  content: string;
  timestamp: string;
  isStreaming?: boolean;
  // üé® Georgian formatting enhancements
  formatted?: GuruloFormattedMessage;
  memoryIntegrated?: boolean;
  contextAware?: boolean;
}

// ===== PHASE 5: PROFESSIONAL FEATURES INTERFACES =====

// üîÑ Checkpoint System
interface Checkpoint {
  id: string;
  name: string;
  description: string;
  timestamp: Date;
  sessionId: string;
  messages: ChatMessage[];
  metadata: {
    userTriggered: boolean;
    autoGenerated: boolean;
    version: string;
    context: string[];
  };
}

// üìä Performance Analytics
interface PerformanceMetrics {
  responseTime: number;
  tokenEfficiency: number;
  accuracyScore: number;
  userSatisfaction: number;
  memoryUsage: number;
  cacheHitRate: number;
  sessionDuration: number;
  messageQuality: number;
  contextRelevance: number;
  georgianLanguageScore: number;
}

// ü§ù Collaboration Features
interface CollaborationData {
  sessionSharing: {
    sharedSessions: string[];
    sharedWith: string[];
    accessLevel: 'read' | 'write' | 'admin';
  };
  knowledgeBase: {
    savedSnippets: CodeSnippet[];
    commonSolutions: Solution[];
    teamLearnings: Learning[];
  };
  teamMetrics: {
    sharedProblems: number;
    resolvedIssues: number;
    knowledgeContributions: number;
  };
}

interface CodeSnippet {
  id: string;
  title: string;
  code: string;
  language: string;
  description: string;
  tags: string[];
  author: string;
  timestamp: Date;
  usage: number;
}

interface Solution {
  id: string;
  problem: string;
  solution: string;
  code?: string;
  effectiveness: number;
  votes: number;
  author: string;
  timestamp: Date;
}

interface Learning {
  id: string;
  topic: string;
  insights: string;
  examples: string[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
  georgianTerms: string[];
  timestamp: Date;
}

// ===== ENHANCED CHAT SESSION INTERFACE =====
interface ChatSession {
  id: string;
  title: string;
  messages: ChatMessage[];
  timestamp: Date;
  lastActivity: Date;
  messageCount: number;
  isArchived?: boolean;
  // PHASE 5: Professional enhancements
  checkpoints: Checkpoint[];
  performance: PerformanceMetrics;
  collaboration: CollaborationData;
  quality: {
    avgResponseTime: number;
    accuracy: number;
    satisfaction: number;
    georgianSupport: number;
  };
  tags: string[];
  favorite: boolean;
}

// ===== CHAT PANEL PROPS =====
interface ChatPanelProps {
  currentFile: { path: string; content: string } | null;
  authUser: any;
  aiFetch: (endpoint: string, options?: RequestInit) => Promise<any>;
  setRequestInspector: React.Dispatch<React.SetStateAction<any>>;
  setConsoleLogs: React.Dispatch<React.SetStateAction<any>>;
  // SOL-212: Replit Assistant Mode Props
  assistantMode: 'basic' | 'advanced';
  setAssistantMode: React.Dispatch<React.SetStateAction<'basic' | 'advanced'>>;
  fileContext: string[];
  setFileContext: React.Dispatch<React.SetStateAction<string[]>>;
  showEditPreview: boolean;
  setShowEditPreview: React.Dispatch<React.SetStateAction<boolean>>;
  pendingEditRequest: any;
  setPendingEditRequest: React.Dispatch<React.SetStateAction<any>>;
}

export default function ChatPanel({
  currentFile,
  authUser,
  aiFetch,
  setRequestInspector,
  setConsoleLogs,
  assistantMode,
  setAssistantMode,
  fileContext,
  setFileContext,
  showEditPreview,
  setShowEditPreview,
  pendingEditRequest,
  setPendingEditRequest
}: ChatPanelProps) {
  // Unused props for future functionality - kept as per spec
  void currentFile;
  void setRequestInspector; 
  void setConsoleLogs;

  // ===== CHATSESSION STATE =====
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);

  // ===== GURULO MEMORY INTEGRATION =====
  const {
    interactions,
    preferences,
    rememberInteraction,
    updateContext,
    getMemoryStats,
    getWebSocketStatus,
    connectWebSocket
  } = useGuruloMemory();

  // ===== CHAT STATE =====
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [chatInput, setChatInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  // ===== GEORGIAN FORMATTING STATE =====
  const [memoryStats, setMemoryStats] = useState(getMemoryStats());

  // üá¨üá™ PHASE 4: Georgian Support State
  const georgianSupport = useGeorgianSupport();
  const [georgianConfig, setGeorgianConfig] = useState<Partial<GeorgianSupportConfig>>({
    enabled: true,
    languageEnhancement: {
      autoCorrection: true,
      transliteration: true,
      mixedLanguageFormatting: true,
      georgianCodeComments: true
    },
    culturalAdaptation: {
      georgianTerminology: true,
      localExamples: true,
      georgianErrors: true,
      regionalContext: true
    },
    userPreferences: {
      explanationLevel: 'intermediate',
      preferredTranslationStyle: 'explanatory',
      showTerminologyHelp: true,
      enableCulturalContext: true,
      complexityLevel: 'intermediate'
    },
    ui: {
      showGeorgianControls: true,
      enableLanguageToggle: true,
      showCapabilities: true,
      enableQuickActions: true
    }
  });
  const [showGeorgianControls, setShowGeorgianControls] = useState(false);

  // ===== SOL-203: ENHANCED CONTROLS =====
  const [showControls, setShowControls] = useState(false);
  const [modelSelection, setModelSelection] = useState<'llama-3.1-8b-instant' | 'llama-3.1-70b-versatile'>('llama-3.1-8b-instant');
  const [streamingEnabled, setStreamingEnabled] = useState(false);
  const [contextDepth, setContextDepth] = useState(3); // 1-5 scale
  const [languageMode, setLanguageMode] = useState<'ka' | 'en' | 'mixed'>('ka');

  // ===== TELEMETRY STATE =====
  const [telemetry, setTelemetry] = useState({
    tokenUsage: { prompt: 0, completion: 0, total: 0 },
    responseLatency: 0,
    successRate: 100,
    modelEfficiency: 85,
    intentClassification: '',
    contextSize: 0,
    memoryCacheHits: 0
  });

  // ===== PHASE 5: PROFESSIONAL FEATURES STATE =====
  
  // üîÑ Checkpoint System State
  const [checkpoints, setCheckpoints] = useState<Checkpoint[]>([]);
  const [showCheckpointPanel, setShowCheckpointPanel] = useState(false);
  const [checkpointName, setCheckpointName] = useState('');
  const [autoCheckpointEnabled, setAutoCheckpointEnabled] = useState(true);
  const [lastCheckpointTime, setLastCheckpointTime] = useState<Date | null>(null);

  // üìä Performance Analytics State
  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({
    responseTime: 0,
    tokenEfficiency: 0,
    accuracyScore: 0,
    userSatisfaction: 0,
    memoryUsage: 0,
    cacheHitRate: 0,
    sessionDuration: 0,
    messageQuality: 0,
    contextRelevance: 0,
    georgianLanguageScore: 0
  });
  const [showPerformancePanel, setShowPerformancePanel] = useState(false);
  const [performanceHistory, setPerformanceHistory] = useState<PerformanceMetrics[]>([]);

  // ü§ù Collaboration Features State
  const [collaborationData, setCollaborationData] = useState<CollaborationData>({
    sessionSharing: {
      sharedSessions: [],
      sharedWith: [],
      accessLevel: 'read'
    },
    knowledgeBase: {
      savedSnippets: [],
      commonSolutions: [],
      teamLearnings: []
    },
    teamMetrics: {
      sharedProblems: 0,
      resolvedIssues: 0,
      knowledgeContributions: 0
    }
  });
  const [showCollaborationPanel, setShowCollaborationPanel] = useState(false);
  const [codeSnippetTitle, setCodeSnippetTitle] = useState('');
  const [shareSessionId, setShareSessionId] = useState('');

  // ===== REPLIT ASSISTANT STATE =====
  const [newFileContext, setNewFileContext] = useState("");

  // ===== CHAT REF =====
  const chatContainerRef = useRef<HTMLDivElement>(null);

  // ===== HELPER FUNCTIONS =====
  const generateSessionTitle = (firstMessage: string): string => {
    const maxLength = 30;
    const trimmedMessage = firstMessage.trim();
    return trimmedMessage.length > maxLength 
      ? trimmedMessage.substring(0, maxLength) + '...' 
      : trimmedMessage || 'Untitled Session';
  };

  const createNewSession = () => {
    const newSession: ChatSession = {
      id: crypto.randomUUID(),
      title: '·Éê·ÉÆ·Éê·Éö·Éò ·É©·Éê·É¢·Éò',
      messages: [],
      timestamp: new Date(),
      lastActivity: new Date(),
      messageCount: 0,
    };
    setChatSessions(prevSessions => [...prevSessions, newSession]);
    setCurrentSessionId(newSession.id);
    setChatMessages([]); // Clear current messages for the new session
  };

  const importSessions = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const importedData = JSON.parse(e.target?.result as string);
        // Basic validation
        if (Array.isArray(importedData) && importedData.every((item: any) => item.id && item.title && item.messages)) {
          const sessions: ChatSession[] = importedData.map((session: any) => ({
            ...session,
            timestamp: new Date(session.timestamp),
            lastActivity: new Date(session.lastActivity),
            messages: session.messages.map((msg: any) => ({
              ...msg,
              timestamp: new Date(msg.timestamp).toISOString() // Ensure timestamp is string for storage
            }))
          }));
          setChatSessions(prev => [...prev, ...sessions]);
          alert(`${sessions.length} sessions imported successfully!`);
        } else {
          alert('Invalid file format. Please upload a valid JSON array of chat sessions.');
        }
      } catch (error) {
        console.error('Failed to import sessions:', error);
        alert('Error importing sessions. Please check the file.');
      }
    };
    reader.readAsText(file);
  };

  const exportSession = (sessionId: string) => {
    const sessionToExport = chatSessions.find(s => s.id === sessionId);
    if (!sessionToExport) return;

    const blob = new Blob([JSON.stringify(sessionToExport, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${sessionToExport.title.replace(/\s+/g, '_')}_${sessionToExport.timestamp.toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const duplicateSession = (sessionId: string) => {
    const sessionToDuplicate = chatSessions.find(s => s.id === sessionId);
    if (!sessionToDuplicate) return;

    const newSession: ChatSession = {
      ...sessionToDuplicate,
      id: crypto.randomUUID(),
      title: `${sessionToDuplicate.title} (Copy)`,
      timestamp: new Date(),
      lastActivity: new Date(),
      messages: sessionToDuplicate.messages.map(msg => ({ ...msg, id: crypto.randomUUID() })), // Ensure unique message IDs
    };
    setChatSessions(prev => [...prev, newSession]);
  };

  const archiveSession = (sessionId: string) => {
    setChatSessions(prev => prev.map(s => 
      s.id === sessionId ? { ...s, isArchived: true } : s
    ));
  };

  const deleteSession = (sessionId: string) => {
    setChatSessions(prev => prev.filter(s => s.id !== sessionId));
    if (currentSessionId === sessionId) {
      setCurrentSessionId(null);
      setChatMessages([]);
    }
  };

  // ===== PHASE 5: PROFESSIONAL FEATURES FUNCTIONS =====

  // üîÑ CHECKPOINT SYSTEM FUNCTIONS
  const createCheckpoint = (name?: string, description?: string, userTriggered = false) => {
    if (!currentSessionId) return;

    const checkpoint: Checkpoint = {
      id: crypto.randomUUID(),
      name: name || `Auto-Checkpoint ${new Date().toLocaleTimeString()}`,
      description: description || `Automatic checkpoint created at ${new Date().toLocaleString()}`,
      timestamp: new Date(),
      sessionId: currentSessionId,
      messages: [...chatMessages],
      metadata: {
        userTriggered,
        autoGenerated: !userTriggered,
        version: '1.0.0',
        context: fileContext
      }
    };

    setCheckpoints(prev => [...prev, checkpoint]);
    setLastCheckpointTime(new Date());

    // Update session with checkpoint
    setChatSessions(prev => prev.map(session => 
      session.id === currentSessionId 
        ? { 
            ...session, 
            checkpoints: [...(session.checkpoints || []), checkpoint]
          }
        : session
    ));

    // Store in localStorage
    localStorage.setItem('gurulo_checkpoints', JSON.stringify([...checkpoints, checkpoint]));
    
    return checkpoint;
  };

  const createManualCheckpoint = () => {
    if (!checkpointName.trim()) {
      alert('·Éí·Éó·ÉÆ·Éù·Éï·Éó ·Éõ·Éò·É£·Éó·Éò·Éó·Éù·Éó checkpoint-·Éò·É° ·É°·Éê·ÉÆ·Éî·Éö·Éò');
      return;
    }

    const checkpoint = createCheckpoint(
      checkpointName,
      `Manual checkpoint: ${checkpointName}`,
      true
    );

    if (checkpoint) {
      setCheckpointName('');
      alert(`‚úÖ Checkpoint "${checkpoint.name}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·É®·Éî·Éò·É•·Éõ·Éú·Éê!`);
    }
  };

  const rollbackToCheckpoint = (checkpointId: string) => {
    const checkpoint = checkpoints.find(cp => cp.id === checkpointId);
    if (!checkpoint) {
      alert('Checkpoint ·Éï·Éî·É† ·Éõ·Éù·Éò·É´·Éî·Éë·Éú·Éê');
      return;
    }

    const confirmed = window.confirm(
      `·Éì·Éê·É†·É¨·Éõ·É£·Éú·Éî·Éë·É£·Éö·Éò ·ÉÆ·Éê·É†·Éó ·É†·Éù·Éõ ·Éí·É°·É£·É†·Éó ·Éì·Éê·Éë·É†·É£·Éú·Éî·Éë·Éê checkpoint-·Éñ·Éî "${checkpoint.name}"?\n\n·Éî·É°·Éî ·Éß·Éï·Éî·Éö·Éê ·É®·Éî·Éõ·Éì·Éî·Éí·Éò message ·É¨·Éê·Éò·É®·Éö·Éî·Éë·Éê.`
    );

    if (confirmed) {
      setChatMessages(checkpoint.messages);
      
      // Create rollback checkpoint before applying
      createCheckpoint(
        `Rollback to ${checkpoint.name}`,
        `Rolled back from ${chatMessages.length} messages to ${checkpoint.messages.length} messages`,
        true
      );

      alert(`‚úÖ ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éï·Éë·É†·É£·Éú·Éì·Éò·Éó checkpoint-·Éñ·Éî "${checkpoint.name}"`);
    }
  };

  const deleteCheckpoint = (checkpointId: string) => {
    const checkpoint = checkpoints.find(cp => cp.id === checkpointId);
    if (!checkpoint) return;

    const confirmed = window.confirm(`·Éí·É°·É£·É†·Éó checkpoint "${checkpoint.name}"-·Éò·É° ·É¨·Éê·É®·Éö·Éê?`);
    if (confirmed) {
      setCheckpoints(prev => prev.filter(cp => cp.id !== checkpointId));
      localStorage.setItem('gurulo_checkpoints', JSON.stringify(checkpoints.filter(cp => cp.id !== checkpointId)));
    }
  };

  // üìä PERFORMANCE ANALYTICS FUNCTIONS
  const updatePerformanceMetrics = (responseData: any, responseTime: number) => {
    const newMetrics: PerformanceMetrics = {
      responseTime,
      tokenEfficiency: responseData.usage?.total_tokens ? (responseData.response?.length || 0) / responseData.usage.total_tokens : 0,
      accuracyScore: calculateAccuracyScore(responseData.response),
      userSatisfaction: calculateUserSatisfaction(),
      memoryUsage: getMemoryUsage(),
      cacheHitRate: memoryStats.cacheHitRate || 0,
      sessionDuration: Date.now() - (new Date(chatSessions.find(s => s.id === currentSessionId)?.timestamp || new Date()).getTime()),
      messageQuality: calculateMessageQuality(responseData.response),
      contextRelevance: calculateContextRelevance(responseData.response),
      georgianLanguageScore: calculateGeorgianLanguageScore(responseData.response)
    };

    setPerformanceMetrics(newMetrics);
    setPerformanceHistory(prev => [...prev.slice(-19), newMetrics]); // Keep last 20 entries

    // Update telemetry with real data
    setTelemetry(prev => ({
      ...prev,
      responseLatency: responseTime,
      tokenUsage: responseData.usage || prev.tokenUsage,
      modelEfficiency: Math.round(newMetrics.tokenEfficiency * 100),
      successRate: calculateSuccessRate(),
      contextSize: fileContext.length,
      memoryCacheHits: memoryStats.interactions || 0
    }));
  };

  const calculateAccuracyScore = (response: string): number => {
    // Georgian language bonus
    const georgianBonus = /[·Éê-·É∞]/.test(response) ? 10 : 0;
    // Code block bonus
    const codeBonus = response.includes('```') ? 15 : 0;
    // Length appropriateness
    const lengthScore = response.length > 50 && response.length < 2000 ? 20 : 10;
    // Emoji and formatting bonus
    const formattingBonus = /[üîßüìãüí°‚ö°üéØ‚úÖ‚ùå‚ö†Ô∏è]/.test(response) ? 10 : 0;
    
    return Math.min(100, 45 + georgianBonus + codeBonus + lengthScore + formattingBonus);
  };

  const calculateUserSatisfaction = (): number => {
    const recentMessages = chatMessages.slice(-10);
    const userMessages = recentMessages.filter(m => m.type === 'user').length;
    const aiMessages = recentMessages.filter(m => m.type === 'ai').length;
    
    // Good conversation flow = balanced messages
    const balanceScore = userMessages > 0 && aiMessages > 0 ? 50 : 20;
    // Session length bonus
    const lengthBonus = Math.min(30, chatMessages.length * 2);
    // Memory integration bonus
    const memoryBonus = recentMessages.some(m => m.memoryIntegrated) ? 20 : 0;
    
    return Math.min(100, balanceScore + lengthBonus + memoryBonus);
  };

  const calculateMessageQuality = (response: string): number => {
    let score = 40; // Base score
    
    // Georgian text quality
    if (/[·Éê-·É∞]/.test(response)) score += 20;
    // Code examples
    if (response.includes('```')) score += 15;
    // Structured content
    if (response.includes('##') || response.includes('###')) score += 10;
    // Emoji usage
    if (/[üîßüìãüí°‚ö°üéØ]/.test(response)) score += 10;
    // Appropriate length
    if (response.length > 100 && response.length < 1500) score += 5;
    
    return Math.min(100, score);
  };

  const calculateContextRelevance = (response: string): number => {
    let relevanceScore = 50; // Base score
    
    // File context relevance
    if (fileContext.length > 0) {
      const contextWords = fileContext.join(' ').toLowerCase();
      const responseWords = response.toLowerCase();
      const matches = contextWords.split(' ').filter(word => 
        word.length > 3 && responseWords.includes(word)
      ).length;
      relevanceScore += Math.min(30, matches * 5);
    }
    
    // Mode relevance
    if (assistantMode === 'advanced' && response.includes('edit')) relevanceScore += 10;
    if (assistantMode === 'basic' && !response.includes('edit')) relevanceScore += 10;
    
    return Math.min(100, relevanceScore);
  };

  const calculateGeorgianLanguageScore = (response: string): number => {
    let score = 0;
    
    // Georgian text presence
    const georgianMatches = response.match(/[·Éê-·É∞]/g);
    if (georgianMatches) {
      score += Math.min(40, georgianMatches.length / 5);
    }
    
    // Mixed language quality
    const hasEnglish = /[a-zA-Z]/.test(response);
    const hasGeorgian = /[·Éê-·É∞]/.test(response);
    if (hasEnglish && hasGeorgian) score += 20;
    
    // Georgian programming terms
    const georgianTerms = ['·Éû·É†·Éù·Éí·É†·Éê·Éõ·Éò·É†·Éî·Éë·Éê', '·Éô·Éù·Éì·Éò', '·É§·É£·Éú·É•·É™·Éò·Éê', '·É™·Éï·Éö·Éê·Éì·Éò', '·Éõ·Éê·É°·Éò·Éï·Éò'];
    georgianTerms.forEach(term => {
      if (response.includes(term)) score += 10;
    });
    
    return Math.min(100, score);
  };

  const calculateSuccessRate = (): number => {
    const recentMessages = chatMessages.slice(-20);
    const aiMessages = recentMessages.filter(m => m.type === 'ai');
    const successfulMessages = aiMessages.filter(m => 
      m.content.length > 50 && !m.content.toLowerCase().includes('error')
    );
    
    return aiMessages.length > 0 ? Math.round((successfulMessages.length / aiMessages.length) * 100) : 100;
  };

  const getMemoryUsage = (): number => {
    // Simulate memory usage calculation
    const sessionSize = JSON.stringify(chatMessages).length;
    const checkpointSize = JSON.stringify(checkpoints).length;
    const totalSize = sessionSize + checkpointSize;
    
    // Convert to percentage (max 100MB simulated)
    return Math.min(100, (totalSize / (100 * 1024 * 1024)) * 100);
  };

  // ü§ù COLLABORATION FEATURES FUNCTIONS
  const shareSession = (sessionId: string) => {
    const session = chatSessions.find(s => s.id === sessionId);
    if (!session) {
      alert('Session ·Éï·Éî·É† ·Éõ·Éù·Éò·É´·Éî·Éë·Éú·Éê');
      return;
    }

    const shareData = {
      id: session.id,
      title: session.title,
      messages: session.messages,
      timestamp: session.timestamp,
      sharedBy: authUser?.personalId || 'anonymous',
      sharedAt: new Date()
    };

    // Copy to clipboard
    navigator.clipboard.writeText(JSON.stringify(shareData, null, 2)).then(() => {
      alert(`‚úÖ Session "${session.title}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éô·Éù·Éû·Éò·É†·Éì·Éê clipboard-·É®·Éò!\n\n·Éí·Éê·É£·Éñ·Éò·Éê·É†·Éî·Éó team member-·Éî·Éë·É°.`);
      
      // Update collaboration data
      setCollaborationData(prev => ({
        ...prev,
        sessionSharing: {
          ...prev.sessionSharing,
          sharedSessions: [...prev.sessionSharing.sharedSessions, sessionId]
        },
        teamMetrics: {
          ...prev.teamMetrics,
          sharedProblems: prev.teamMetrics.sharedProblems + 1
        }
      }));
    }).catch(() => {
      alert('·Éô·Éù·Éû·Éò·É†·Éî·Éë·Éê ·Éï·Éî·É† ·Éõ·Éù·ÉÆ·Éî·É†·ÉÆ·Éì·Éê');
    });
  };

  const exportCodeSnippet = (code: string, language: string = 'typescript') => {
    if (!codeSnippetTitle.trim()) {
      alert('·Éí·Éó·ÉÆ·Éù·Éï·Éó ·Éõ·Éò·É£·Éó·Éò·Éó·Éù·Éó code snippet-·Éò·É° ·É°·Éê·Éó·Éê·É£·É†·Éò');
      return;
    }

    const snippet: CodeSnippet = {
      id: crypto.randomUUID(),
      title: codeSnippetTitle,
      code,
      language,
      description: `Exported from Gurulo AI session: ${chatSessions.find(s => s.id === currentSessionId)?.title || 'Unknown'}`,
      tags: ['gurulo-ai', 'exported', language],
      author: authUser?.personalId || 'anonymous',
      timestamp: new Date(),
      usage: 0
    };

    // Add to knowledge base
    setCollaborationData(prev => ({
      ...prev,
      knowledgeBase: {
        ...prev.knowledgeBase,
        savedSnippets: [...prev.knowledgeBase.savedSnippets, snippet]
      },
      teamMetrics: {
        ...prev.teamMetrics,
        knowledgeContributions: prev.teamMetrics.knowledgeContributions + 1
      }
    }));

    // Export as file
    const blob = new Blob([code], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${codeSnippetTitle.replace(/\s+/g, '_')}.${getFileExtension(language)}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    setCodeSnippetTitle('');
    alert(`‚úÖ Code snippet "${snippet.title}" ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éí·Éê·Éì·Éê·Éõ·Éù·É¢·Éê·Éú·Éò·Éö·Éò ·Éì·Éê knowledge base-·É®·Éò ·Éì·Éê·Éõ·Éê·É¢·Éî·Éë·É£·Éö·Éò!`);
  };

  const getFileExtension = (language: string): string => {
    const extensions: Record<string, string> = {
      'typescript': 'ts',
      'javascript': 'js',
      'python': 'py',
      'java': 'java',
      'css': 'css',
      'html': 'html',
      'json': 'json',
      'sql': 'sql'
    };
    return extensions[language] || 'txt';
  };

  const addToKnowledgeBase = (problem: string, solution: string, code?: string) => {
    const newSolution: Solution = {
      id: crypto.randomUUID(),
      problem,
      solution,
      code,
      effectiveness: 85, // Default rating
      votes: 1,
      author: authUser?.personalId || 'anonymous',
      timestamp: new Date()
    };

    setCollaborationData(prev => ({
      ...prev,
      knowledgeBase: {
        ...prev.knowledgeBase,
        commonSolutions: [...prev.knowledgeBase.commonSolutions, newSolution]
      },
      teamMetrics: {
        ...prev.teamMetrics,
        resolvedIssues: prev.teamMetrics.resolvedIssues + 1
      }
    }));

    alert('‚úÖ ·Éê·ÉÆ·Éê·Éö·Éò ·Éí·Éê·Éì·Éê·É¨·Éß·Éï·Éî·É¢·Éê ·É¨·Éê·É†·Éõ·Éê·É¢·Éî·Éë·Éò·Éó ·Éì·Éê·Éî·Éõ·Éê·É¢·Éê Knowledge Base-·É®·Éò!');
  };

  // ===== PHASE 2: CHAT SESSIONS MANAGEMENT =====

  // Load chat sessions from localStorage on mount
  useEffect(() => {
    const savedSessions = localStorage.getItem('gurulo_chat_sessions');
    if (savedSessions) {
      try {
        const sessions = JSON.parse(savedSessions).map((session: any) => ({
          ...session,
          timestamp: new Date(session.timestamp),
          lastActivity: new Date(session.lastActivity)
        }));
        setChatSessions(sessions);

        // Load the most recent session if no current session is set
        if (sessions.length > 0 && !currentSessionId) {
          const mostRecent = sessions.sort((a: ChatSession, b: ChatSession) => 
            b.lastActivity.getTime() - a.lastActivity.getTime()
          )[0];
          setCurrentSessionId(mostRecent.id);
          setChatMessages(mostRecent.messages || []);
        } else if (sessions.length === 0) {
          // Create initial session if storage was empty or invalid
          createNewSession();
        }
      } catch (error) {
        console.error('Failed to load chat sessions:', error);
        // Create initial session if loading fails
        createNewSession();
      }
    } else {
      // Create initial session if none exists
      createNewSession();
    }
  }, []);

  // Save chat sessions to localStorage whenever they change
  useEffect(() => {
    // Filter out archived sessions before saving if desired, or keep them
    const sessionsToSave = chatSessions.map(session => ({
      ...session,
      // Ensure dates are serialized correctly for JSON storage
      timestamp: session.timestamp.toISOString(),
      lastActivity: session.lastActivity.toISOString(),
      messages: session.messages.map(msg => ({
        ...msg,
        // Ensure message timestamps are strings for storage
        timestamp: msg.timestamp,
      })),
    }));
    localStorage.setItem('gurulo_chat_sessions', JSON.stringify(sessionsToSave));
  }, [chatSessions]);

  // Update current session messages when chatMessages change
  useEffect(() => {
    if (currentSessionId && chatMessages.length > 0) {
      setChatSessions(prev => prev.map(session => 
        session.id === currentSessionId 
          ? { 
              ...session, 
              messages: chatMessages,
              messageCount: chatMessages.length,
              lastActivity: new Date(),
              // Auto-generate title from first user message if it's a new session title
              title: session.title === '·Éê·ÉÆ·Éê·Éö·Éò ·É©·Éê·É¢·Éò' && chatMessages.length > 0 
                ? generateSessionTitle(chatMessages[0]?.content || '')
                : session.title
            }
          : session
      ));
    } else if (currentSessionId && chatMessages.length === 0) {
       // If current session messages are cleared, update the session record
       setChatSessions(prev => prev.map(session => 
         session.id === currentSessionId 
           ? { ...session, messageCount: 0, lastActivity: new Date() } 
           : session
       ));
    }
  }, [chatMessages, currentSessionId]);

  // ===== GURULO MEMORY EFFECTS =====
  useEffect(() => {
    // Update memory stats periodically
    const updateStats = () => setMemoryStats(getMemoryStats());
    const interval = setInterval(updateStats, 30000);
    return () => clearInterval(interval);
  }, [getMemoryStats]);

  useEffect(() => {
    // Connect WebSocket and update project context
    connectWebSocket();
    updateContext(
      'Bakhmaro Cottages Platform',
      'Chat ·É°·Éò·É°·É¢·Éî·Éõ·Éò·É° ·Éí·Éê·Éú·Éï·Éò·Éó·Éê·É†·Éî·Éë·Éê',
      fileContext
    );
  }, [connectWebSocket, updateContext, fileContext]);

  // ===== PHASE 5: PROFESSIONAL FEATURES DATA PERSISTENCE =====

  // üîÑ Load checkpoints from localStorage
  useEffect(() => {
    const savedCheckpoints = localStorage.getItem('gurulo_checkpoints');
    if (savedCheckpoints) {
      try {
        const checkpoints = JSON.parse(savedCheckpoints).map((cp: any) => ({
          ...cp,
          timestamp: new Date(cp.timestamp)
        }));
        setCheckpoints(checkpoints);
      } catch (error) {
        console.error('Failed to load checkpoints:', error);
      }
    }
  }, []);

  // üìä Load performance history from localStorage
  useEffect(() => {
    const savedPerformance = localStorage.getItem('gurulo_performance_history');
    if (savedPerformance) {
      try {
        const performanceData = JSON.parse(savedPerformance);
        setPerformanceHistory(performanceData);
      } catch (error) {
        console.error('Failed to load performance history:', error);
      }
    }
  }, []);

  // ü§ù Load collaboration data from localStorage
  useEffect(() => {
    const savedCollaboration = localStorage.getItem('gurulo_collaboration_data');
    if (savedCollaboration) {
      try {
        const collaborationData = JSON.parse(savedCollaboration);
        setCollaborationData(prev => ({
          ...prev,
          ...collaborationData,
          knowledgeBase: {
            ...prev.knowledgeBase,
            ...collaborationData.knowledgeBase,
            savedSnippets: collaborationData.knowledgeBase?.savedSnippets?.map((snippet: any) => ({
              ...snippet,
              timestamp: new Date(snippet.timestamp)
            })) || [],
            commonSolutions: collaborationData.knowledgeBase?.commonSolutions?.map((solution: any) => ({
              ...solution,
              timestamp: new Date(solution.timestamp)
            })) || [],
            teamLearnings: collaborationData.knowledgeBase?.teamLearnings?.map((learning: any) => ({
              ...learning,
              timestamp: new Date(learning.timestamp)
            })) || []
          }
        }));
      } catch (error) {
        console.error('Failed to load collaboration data:', error);
      }
    }
  }, []);

  // üîÑ Save checkpoints to localStorage whenever they change
  useEffect(() => {
    if (checkpoints.length > 0) {
      localStorage.setItem('gurulo_checkpoints', JSON.stringify(checkpoints.map(cp => ({
        ...cp,
        timestamp: cp.timestamp.toISOString()
      }))));
    }
  }, [checkpoints]);

  // üìä Save performance history to localStorage
  useEffect(() => {
    if (performanceHistory.length > 0) {
      localStorage.setItem('gurulo_performance_history', JSON.stringify(performanceHistory));
    }
  }, [performanceHistory]);

  // ü§ù Save collaboration data to localStorage
  useEffect(() => {
    localStorage.setItem('gurulo_collaboration_data', JSON.stringify({
      ...collaborationData,
      knowledgeBase: {
        ...collaborationData.knowledgeBase,
        savedSnippets: collaborationData.knowledgeBase.savedSnippets.map(snippet => ({
          ...snippet,
          timestamp: snippet.timestamp.toISOString()
        })),
        commonSolutions: collaborationData.knowledgeBase.commonSolutions.map(solution => ({
          ...solution,
          timestamp: solution.timestamp.toISOString()
        })),
        teamLearnings: collaborationData.knowledgeBase.teamLearnings.map(learning => ({
          ...learning,
          timestamp: learning.timestamp.toISOString()
        }))
      }
    }));
  }, [collaborationData]);

  // ===== ENHANCED CHAT FUNCTIONS WITH PROFESSIONAL FEATURES =====
  const sendMessage = async () => {
    if (!chatInput.trim()) return;

    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      type: "user",
      content: chatInput,
      timestamp: new Date().toISOString(),
      memoryIntegrated: false,
      contextAware: false
    };

    setChatMessages(prev => [...prev, userMessage]);
    const currentInput = chatInput;
    setChatInput("");
    setIsLoading(true);

    // üìä PHASE 5: Start performance tracking
    const startTime = Date.now();

    try {
      const data = await aiFetch("chat", {
        method: "POST",
        body: JSON.stringify({
          message: currentInput,
          personalId: authUser?.personalId || 'anonymous_user',
          mode: assistantMode,
          fileContext: fileContext,
          context: {
            isAdvanced: assistantMode === 'advanced',
            requestType: assistantMode === 'advanced' ? 'edit_request' : 'basic_query',
            currentFile: currentFile?.path || null
          }
        }),
      });

      // üìä PHASE 5: Calculate response time
      const responseTime = Date.now() - startTime;

      // Handle Advanced mode edit requests
      if (data.editRequest && assistantMode === 'advanced') {
        setPendingEditRequest(data.editRequest);
        setShowEditPreview(true);

        const editMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          type: "ai",
          content: `üîß **Edit Request Created**\n\n${data.response}\n\n‚ö†Ô∏è *Review the changes below and approve to proceed*`,
          timestamp: new Date().toISOString(),
          memoryIntegrated: true,
          contextAware: true
        };
        setChatMessages(prev => [...prev, editMessage]);

        // üß† Record interaction for advanced edit flow
        rememberInteraction(
          currentInput,
          data.response,
          `Context: ${fileContext.join(', ')}, Mode: advanced, EditRequest: ${data.editRequest?.type || 'unknown'}`
        );

        // üìä PHASE 5: Update performance metrics for edit requests
        updatePerformanceMetrics({
          response: data.response,
          usage: data.usage || { total_tokens: 0 }
        }, responseTime);

        // üîÑ PHASE 5: Auto-checkpoint for edit requests
        if (autoCheckpointEnabled) {
          createCheckpoint(
            `Edit Request: ${data.editRequest?.type || 'Unknown'}`,
            `Auto-checkpoint before edit request: ${currentInput.substring(0, 50)}...`,
            false
          );
        }

      } else {
        // üá¨üá™ PHASE 4: Enhanced Georgian processing with full support
        const baseResponse = data.response || "Sorry, I encountered an error.";
        
        // Process with Georgian Support system
        const georgianProcessedResponse = georgianSupport.processMessage(
          baseResponse,
          {
            ...preferences,
            ...georgianConfig.userPreferences,
            explanationLevel: georgianConfig.userPreferences?.explanationLevel || 'intermediate',
            enableGeorgianFeatures: georgianConfig.enabled,
            enableCulturalAdaptation: georgianConfig.culturalAdaptation?.georgianTerminology,
            enableTerminologyMapping: georgianConfig.culturalAdaptation?.georgianTerminology,
            showTerminologyHelp: georgianConfig.userPreferences?.showTerminologyHelp
          },
          interactions.slice(-5) // Recent interactions for context
        );
        
        // Legacy formatting for compatibility
        const formattedResponse = georgianProcessedResponse;

        const aiMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          type: "ai",
          content: addGeorgianSignature(formattedResponse.content),
          timestamp: new Date().toISOString(),
          formatted: formattedResponse,
          memoryIntegrated: true,
          contextAware: true
        };

        // üß† Record single interaction in Gurulo memory
        rememberInteraction(
          currentInput,
          baseResponse,
          `Context: ${fileContext.join(', ')}, Mode: ${assistantMode}`
        );
        setChatMessages(prev => [...prev, aiMessage]);

        // üìä PHASE 5: Update performance metrics for normal responses
        updatePerformanceMetrics({
          response: baseResponse,
          usage: data.usage || { total_tokens: 0 }
        }, responseTime);

        // üîÑ PHASE 5: Auto-checkpoint for successful responses
        if (autoCheckpointEnabled && chatMessages.length > 0 && chatMessages.length % 3 === 0) {
          createCheckpoint(
            `Auto-Checkpoint ${Math.floor(chatMessages.length / 3)}`,
            `Auto-checkpoint after ${chatMessages.length + 2} messages`,
            false
          );
        }

        // ü§ù PHASE 5: Auto-add valuable responses to knowledge base
        if (baseResponse.includes('```') && baseResponse.length > 200) {
          const codeBlocks = baseResponse.match(/```[\w]*\n([\s\S]*?)```/g);
          if (codeBlocks) {
            addToKnowledgeBase(
              currentInput,
              baseResponse,
              codeBlocks[0]
            );
          }
        }
      }
    } catch (error: any) {
      console.error("Chat error:", error);
      
      // üìä PHASE 5: Track error response time
      const errorResponseTime = Date.now() - startTime;
      
      // üá¨üá™ PHASE 4: Georgian error translation
      const originalError = "Sorry, I'm having trouble connecting to the AI service.";
      const translatedError = georgianConfig.culturalAdaptation?.georgianErrors 
        ? georgianSupport.translateError(originalError, error.name || 'NetworkError')
        : originalError;
      
      const errorMessage: ChatMessage = {
        id: (Date.now() + 1).toString(),
        type: "ai",
        content: translatedError,
        timestamp: new Date().toISOString(),
      };
      setChatMessages(prev => [...prev, errorMessage]);

      // üìä PHASE 5: Update metrics for error case
      updatePerformanceMetrics({
        response: translatedError,
        usage: { total_tokens: 0 }
      }, errorResponseTime);
      
    } finally {
      setIsLoading(false);
    }
  };

  const handleClearChat = () => {
    setChatMessages([]);
  };

  // ===== FILE CONTEXT FUNCTIONS =====
  const addFileContext = () => {
    if (newFileContext.trim() && !fileContext.includes(newFileContext.trim())) {
      setFileContext([...fileContext, newFileContext.trim()]);
      setNewFileContext("");
    }
  };

  const removeFileContext = (file: string) => {
    setFileContext(fileContext.filter(f => f !== file));
  };

  // ===== EDIT REQUEST FUNCTIONS =====
  const approveEditRequest = async () => {
    if (pendingEditRequest) {
      try {
        // Simulate approval process
        const approvalMessage: ChatMessage = {
          id: Date.now().toString(),
          type: "ai",
          content: "‚úÖ **Edit Request Approved!**\\n\\nChanges have been applied successfully. Checkpoint created for rollback if needed.",
          timestamp: new Date().toISOString(),
        };
        setChatMessages(prev => [...prev, approvalMessage]);
        setPendingEditRequest(null);
        setShowEditPreview(false);
      } catch (error: any) {
        console.error('Edit approval failed:', error);
      }
    }
  };

  const rejectEditRequest = () => {
    const rejectionMessage: ChatMessage = {
      id: Date.now().toString(),
      type: "ai",
      content: "‚ùå **Edit Request Cancelled**\\n\\nNo changes were made to your files.",
      timestamp: new Date().toISOString(),
    };
    setChatMessages(prev => [...prev, rejectionMessage]);
    setPendingEditRequest(null);
    setShowEditPreview(false);
  };


  // ===== RENDER CHAT UI =====
  return (
    <div className="h-full flex flex-col bg-gray-800">
      {/* Header with Mode Selection */}
      <div className="p-4 border-b border-gray-700 bg-gradient-to-r from-gray-800 to-gray-750">
        <div className="flex items-center justify-between mb-3">
          <div className="flex items-center space-x-4">
            <div className="flex items-center">
              <div className="relative">
                <div className="bg-gradient-to-r from-blue-500 to-green-500 p-2 rounded-full">
                  <Bot size={24} className="text-white" />
                </div>
                <div className="absolute -top-1 -right-1 w-4 h-4 bg-green-500 rounded-full animate-pulse border-2 border-gray-800 flex items-center justify-center">
                  <div className="w-2 h-2 bg-white rounded-full"></div>
                </div>
              </div>
              <div className="ml-4">
                <h3 className="text-white font-bold text-xl bg-gradient-to-r from-blue-400 to-green-400 bg-clip-text text-transparent">ü§ñ ·Éí·É£·É†·É£·Éö·Éù AI ·Éê·É°·Éò·É°·É¢·Éî·Éú·É¢·Éò</h3>
                <p className="text-sm text-gray-300 font-medium">Advanced Georgian AI Developer</p>
                <p className="text-xs text-gray-500">‚ú® Replit Assistant ·Éì·Éù·Éú·Éî·Éñ·Éî</p>
              </div>
            </div>
            {/* SOL-203: Real-time Telemetry Display */}
            <div className="flex items-center space-x-3 text-xs text-gray-400">
              <div className="flex items-center space-x-1">
                <Target className="w-3 h-3" />
                <span>{telemetry.tokenUsage.total} tokens</span>
              </div>
              <div className="flex items-center space-x-1">
                <Clock className="w-3 h-3" />
                <span>{telemetry.responseLatency}ms</span>
              </div>
              <div className="flex items-center space-x-1">
                <BarChart3 className="w-3 h-3" />
                <span>{telemetry.successRate}%</span>
              </div>
              {telemetry.intentClassification && (
                <div className="flex items-center space-x-1">
                  <Brain className="w-3 h-3" />
                  <span className="text-blue-300">{telemetry.intentClassification}</span>
                </div>
              )}
            </div>
          </div>
          <div className="flex items-center space-x-2">
            {/* üîÑ PHASE 5: Checkpoint System Button */}
            <button 
              onClick={() => setShowCheckpointPanel(!showCheckpointPanel)} 
              className="text-yellow-400 hover:text-yellow-300 relative" 
              title="Checkpoint System"
            >
              <Save size={16} />
              {checkpoints.length > 0 && (
                <span className="absolute -top-1 -right-1 w-3 h-3 bg-yellow-500 text-xs rounded-full flex items-center justify-center text-black font-bold">
                  {checkpoints.length}
                </span>
              )}
            </button>

            {/* üìä PHASE 5: Performance Analytics Button */}
            <button 
              onClick={() => setShowPerformancePanel(!showPerformancePanel)} 
              className="text-green-400 hover:text-green-300 relative" 
              title="Performance Analytics"
            >
              <TrendingUp size={16} />
              <span className="absolute -bottom-1 -right-1 w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
            </button>

            {/* ü§ù PHASE 5: Collaboration Features Button */}
            <button 
              onClick={() => setShowCollaborationPanel(!showCollaborationPanel)} 
              className="text-blue-400 hover:text-blue-300 relative" 
              title="Collaboration Features"
            >
              <Users size={16} />
              {collaborationData.knowledgeBase.savedSnippets.length > 0 && (
                <span className="absolute -top-1 -right-1 w-3 h-3 bg-blue-500 text-xs rounded-full flex items-center justify-center text-white font-bold">
                  {collaborationData.knowledgeBase.savedSnippets.length}
                </span>
              )}
            </button>

            <button 
              onClick={() => setShowControls(!showControls)} 
              className="text-gray-400 hover:text-white" 
              title="AI Controls"
            >
              <Settings size={16} />
            </button>
            <button onClick={handleClearChat} className="text-gray-400 hover:text-white" title="Clear chat">
              <Trash2 size={16} />
            </button>
          </div>
        </div>

        {/* SOL-203: Advanced Controls Panel */}
        {showControls && (
          <div className="mb-3 p-3 bg-gray-700/50 rounded border border-gray-600">
            <div className="text-sm text-gray-300 mb-2">‚öôÔ∏è AI Controls & Telemetry</div>
            <div className="grid grid-cols-2 gap-3 text-xs">
              <div>
                <label className="block text-gray-400 mb-1">üß† Model:</label>
                <select 
                  value={modelSelection}
                  onChange={(e) => setModelSelection(e.target.value as any)}
                  className="w-full bg-gray-800 text-gray-200 px-2 py-1 rounded border border-gray-600"
                >
                  <option value="llama-3.1-8b-instant">LLaMA 3.1 8B (Fast)</option>
                  <option value="llama-3.1-70b-versatile">LLaMA 3.1 70B (Smart)</option>
                </select>
              </div>
              <div>
                <label className="block text-gray-400 mb-1">üåç Language:</label>
                <select 
                  value={languageMode}
                  onChange={(e) => setLanguageMode(e.target.value as any)}
                  className="w-full bg-gray-800 text-gray-200 px-2 py-1 rounded border border-gray-600"
                >
                  <option value="ka">üá¨üá™ ·É•·Éê·É†·Éó·É£·Éö·Éò</option>
                  <option value="en">üá∫üá∏ English</option>
                  <option value="mixed">üîÑ Mixed</option>
                </select>
              </div>
              <div>
                <label className="flex items-center space-x-2">
                  <input 
                    type="checkbox" 
                    checked={streamingEnabled}
                    onChange={(e) => setStreamingEnabled(e.target.checked)}
                    className="rounded"
                  />
                  <span className="text-gray-400">‚ö° Streaming</span>
                </label>
              </div>
              <div>
                <label className="block text-gray-400 mb-1">üìä Context: {contextDepth}/5</label>
                <input
                  type="range"
                  min="1"
                  max="5"
                  value={contextDepth}
                  onChange={(e) => setContextDepth(parseInt(e.target.value))}
                  className="w-full"
                />
              </div>
            </div>
          </div>
        )}

        {/* üîÑ PHASE 5: CHECKPOINT SYSTEM PANEL */}
        {showCheckpointPanel && (
          <div className="mb-3 p-3 bg-yellow-900/20 rounded border border-yellow-600/30">
            <div className="text-sm text-yellow-300 mb-3 flex items-center justify-between">
              <span>üîÑ Checkpoint System</span>
              <div className="flex items-center space-x-2">
                <label className="flex items-center space-x-1 text-xs">
                  <input
                    type="checkbox"
                    checked={autoCheckpointEnabled}
                    onChange={(e) => setAutoCheckpointEnabled(e.target.checked)}
                  />
                  <span>Auto-checkpoints</span>
                </label>
                {lastCheckpointTime && (
                  <span className="text-xs text-yellow-400">
                    Last: {lastCheckpointTime.toLocaleTimeString()}
                  </span>
                )}
              </div>
            </div>
            
            {/* Manual Checkpoint Creation */}
            <div className="mb-3 flex space-x-2">
              <input
                type="text"
                value={checkpointName}
                onChange={(e) => setCheckpointName(e.target.value)}
                placeholder="Checkpoint name..."
                className="flex-1 bg-gray-800 text-gray-200 px-2 py-1 rounded text-xs border border-gray-600"
              />
              <button
                onClick={createManualCheckpoint}
                disabled={!checkpointName.trim()}
                className="px-2 py-1 bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-600 text-white rounded text-xs"
              >
                <Save size={12} />
              </button>
            </div>

            {/* Checkpoint List */}
            <div className="max-h-32 overflow-y-auto space-y-1">
              {checkpoints.slice(-5).reverse().map((checkpoint) => (
                <div key={checkpoint.id} className="flex items-center justify-between bg-gray-800/50 p-2 rounded text-xs">
                  <div className="flex-1">
                    <div className="text-yellow-300 font-medium">{checkpoint.name}</div>
                    <div className="text-gray-400 text-xs">
                      {checkpoint.timestamp.toLocaleString()} ‚Ä¢ {checkpoint.messages.length} messages
                    </div>
                  </div>
                  <div className="flex space-x-1">
                    <button
                      onClick={() => rollbackToCheckpoint(checkpoint.id)}
                      className="text-green-400 hover:text-green-300"
                      title="Rollback"
                    >
                      <RotateCcw size={12} />
                    </button>
                    <button
                      onClick={() => deleteCheckpoint(checkpoint.id)}
                      className="text-red-400 hover:text-red-300"
                      title="Delete"
                    >
                      <Trash2 size={12} />
                    </button>
                  </div>
                </div>
              ))}
              {checkpoints.length === 0 && (
                <div className="text-gray-500 text-xs italic">No checkpoints yet</div>
              )}
            </div>
          </div>
        )}

        {/* üìä PHASE 5: PERFORMANCE ANALYTICS PANEL */}
        {showPerformancePanel && (
          <div className="mb-3 p-3 bg-green-900/20 rounded border border-green-600/30">
            <div className="text-sm text-green-300 mb-3">üìä Performance Analytics</div>
            
            <div className="grid grid-cols-3 gap-2 text-xs">
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Response Time</div>
                <div className="text-green-300 font-bold">{performanceMetrics.responseTime}ms</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Accuracy</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.accuracyScore)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">User Satisfaction</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.userSatisfaction)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Token Efficiency</div>
                <div className="text-green-300 font-bold">{(performanceMetrics.tokenEfficiency * 100).toFixed(1)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Georgian Score</div>
                <div className="text-green-300 font-bold">{Math.round(performanceMetrics.georgianLanguageScore)}%</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded">
                <div className="text-gray-400">Memory Usage</div>
                <div className="text-green-300 font-bold">{performanceMetrics.memoryUsage.toFixed(1)}%</div>
              </div>
            </div>

            {/* Session Quality Metrics */}
            <div className="mt-2 p-2 bg-gray-800/30 rounded">
              <div className="text-xs text-gray-400 mb-1">Session Quality Overview</div>
              <div className="flex space-x-3 text-xs">
                <span className="text-blue-300">Messages: {chatMessages.length}</span>
                <span className="text-yellow-300">Avg Response: {telemetry.responseLatency}ms</span>
                <span className="text-green-300">Success Rate: {telemetry.successRate}%</span>
                <span className="text-purple-300">Context: {telemetry.contextSize} files</span>
              </div>
            </div>
          </div>
        )}

        {/* ü§ù PHASE 5: COLLABORATION FEATURES PANEL */}
        {showCollaborationPanel && (
          <div className="mb-3 p-3 bg-blue-900/20 rounded border border-blue-600/30">
            <div className="text-sm text-blue-300 mb-3">ü§ù Collaboration Features</div>
            
            {/* Session Sharing */}
            <div className="mb-3">
              <div className="text-xs text-gray-400 mb-1">Session Sharing</div>
              <div className="flex space-x-2">
                <button
                  onClick={() => currentSessionId && shareSession(currentSessionId)}
                  disabled={!currentSessionId}
                  className="px-2 py-1 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 text-white rounded text-xs flex items-center space-x-1"
                >
                  <Share2 size={12} />
                  <span>Share Session</span>
                </button>
                <span className="text-xs text-gray-500 flex items-center">
                  Shared: {collaborationData.teamMetrics.sharedProblems}
                </span>
              </div>
            </div>

            {/* Code Snippet Export */}
            <div className="mb-3">
              <div className="text-xs text-gray-400 mb-1">Code Snippet Export</div>
              <div className="flex space-x-2">
                <input
                  type="text"
                  value={codeSnippetTitle}
                  onChange={(e) => setCodeSnippetTitle(e.target.value)}
                  placeholder="Snippet title..."
                  className="flex-1 bg-gray-800 text-gray-200 px-2 py-1 rounded text-xs border border-gray-600"
                />
                <button
                  onClick={() => {
                    const lastMessage = chatMessages.slice().reverse().find(m => m.type === 'ai' && m.content.includes('```'));
                    if (lastMessage) {
                      const codeMatch = lastMessage.content.match(/```[\w]*\n([\s\S]*?)```/);
                      if (codeMatch) {
                        exportCodeSnippet(codeMatch[1], 'typescript');
                      }
                    }
                  }}
                  disabled={!codeSnippetTitle.trim()}
                  className="px-2 py-1 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 text-white rounded text-xs flex items-center space-x-1"
                >
                  <Download size={12} />
                  <span>Export</span>
                </button>
              </div>
            </div>

            {/* Knowledge Base Stats */}
            <div className="grid grid-cols-3 gap-2 text-xs">
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.knowledgeBase.savedSnippets.length}</div>
                <div className="text-gray-400">Snippets</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.knowledgeBase.commonSolutions.length}</div>
                <div className="text-gray-400">Solutions</div>
              </div>
              <div className="bg-gray-800/50 p-2 rounded text-center">
                <div className="text-blue-300 font-bold">{collaborationData.teamMetrics.knowledgeContributions}</div>
                <div className="text-gray-400">Contributions</div>
              </div>
            </div>

            {/* Recent Knowledge Base Items */}
            {collaborationData.knowledgeBase.savedSnippets.length > 0 && (
              <div className="mt-2">
                <div className="text-xs text-gray-400 mb-1">Recent Snippets</div>
                <div className="max-h-20 overflow-y-auto space-y-1">
                  {collaborationData.knowledgeBase.savedSnippets.slice(-3).reverse().map((snippet) => (
                    <div key={snippet.id} className="bg-gray-800/30 p-1 rounded text-xs">
                      <div className="text-blue-300">{snippet.title}</div>
                      <div className="text-gray-500">{snippet.language} ‚Ä¢ {snippet.timestamp.toLocaleDateString()}</div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Replit Assistant Mode Selection */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm text-gray-400">üéõÔ∏è Mode:</span>
            <button
              onClick={() => setAssistantMode('basic')}
              className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                assistantMode === 'basic'
                  ? 'bg-green-600 text-white'
                  : 'bg-gray-600 text-gray-300 hover:bg-gray-500'
              }`}
            >
              üÜì Basic
            </button>
            <button
              onClick={() => setAssistantMode('advanced')}
              className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                assistantMode === 'advanced'
                  ? 'bg-orange-600 text-white'
                  : 'bg-gray-600 text-gray-300 hover:bg-gray-500'
              }`}
            >
              ‚ö° Advanced
            </button>
          </div>
          <div className="text-xs text-gray-500">
            {assistantMode === 'basic' ? '·Éê·ÉÆ·É°·Éú·Éê/·É†·Éî·Éô·Éù·Éõ·Éî·Éú·Éì·Éê·É™·Éò·Éî·Éë·Éò' : '·Éô·Éù·Éì·Éò·É° ·É†·Éî·Éì·Éê·É•·É¢·Éò·É†·Éî·Éë·Éê'}
          </div>
        </div>
      </div>

      {/* Enhanced Chat Session Sidebar */}
      <div className="w-80 bg-gray-800 border-r border-gray-700 flex flex-col overflow-hidden">
        {/* Sidebar Header */}
        <div className="p-4 border-b border-gray-700 bg-gradient-to-r from-gray-800 to-gray-750">
          <div className="flex items-center justify-between mb-3">
            <div className="flex items-center space-x-2">
              <h4 className="text-white font-bold text-lg">üí¨ Chat Sessions</h4>
              <span className="text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded-full">
                {chatSessions.length}
              </span>
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="file"
                accept=".json"
                onChange={importSessions}
                className="hidden"
                id="import-session"
              />
              <button 
                onClick={() => document.getElementById('import-session')?.click()} 
                className="text-gray-400 hover:text-white p-1 rounded" 
                title="Import Session"
              >
                üì•
              </button>
              <button 
                onClick={createNewSession} 
                className="text-blue-400 hover:text-blue-300 p-1 rounded bg-blue-900/30 hover:bg-blue-900/50" 
                title="New Chat Session"
              >
                <Zap size={18} />
              </button>
            </div>
          </div>

          {/* Session Stats */}
          <div className="flex items-center space-x-4 text-xs text-gray-400">
            <div className="flex items-center space-x-1">
              <Activity className="w-3 h-3" />
              <span>·Éõ·Éî·ÉÆ·É°·Éò·Éî·É†·Éî·Éë·Éê: {memoryStats.totalInteractions}</span>
            </div>
            <div className="flex items-center space-x-1">
              <Clock className="w-3 h-3" />
              <span>·Éì·É¶·Éî·É°: {chatSessions.filter(s => 
                new Date(s.lastActivity).toDateString() === new Date().toDateString()
              ).length}</span>
            </div>
          </div>
        </div>

        {/* Sessions List */}
        <div className="flex-1 overflow-y-auto p-2">
          {chatSessions.length === 0 ? (
            <div className="text-center text-gray-500 py-8">
              <Bot className="w-12 h-12 mx-auto mb-3 opacity-50" />
              <p className="text-sm">·ÉØ·Éî·É† ·Éê·É† ·Éê·É†·Éò·É° ·É©·Éê·É¢·Éò·É° ·É°·Éî·É°·Éò·Éê</p>
              <button 
                onClick={createNewSession}
                className="mt-2 text-blue-400 hover:text-blue-300 text-xs underline"
              >
                ·É®·Éî·É•·Éõ·Éî·Éú·Éò ·Éû·Éò·É†·Éï·Éî·Éö·Éò ·É©·Éê·É¢·Éò
              </button>
            </div>
          ) : (
            <div className="space-y-2">
              {chatSessions
                .filter(session => !session.isArchived)
                .map((session) => (
                <div
                  key={session.id}
                  className={`group relative p-3 rounded-lg cursor-pointer transition-all duration-200 hover:shadow-lg ${
                    session.id === currentSessionId
                      ? 'bg-gradient-to-r from-blue-600 to-blue-700 text-white border border-blue-500'
                      : 'bg-gray-700 text-gray-300 hover:bg-gray-600 border border-gray-600'
                  }`}
                >
                  {/* Session Content */}
                  <div 
                    onClick={() => {
                      setCurrentSessionId(session.id);
                      setChatMessages(session.messages || []);
                    }}
                    className="flex-1"
                  >
                    <div className="flex justify-between items-start mb-2">
                      <span className="font-medium text-sm truncate pr-2 max-w-[200px]">
                        {session.title}
                      </span>
                      <div className="flex items-center space-x-1 text-xs opacity-75">
                        <span>{session.messageCount}</span>
                        <span>msg</span>
                      </div>
                    </div>

                    <div className="text-xs opacity-75 mb-2">
                      {session.lastActivity.toLocaleDateString('ka-GE', { 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </div>

                    {/* Preview of last message */}
                    {session.messages && session.messages.length > 0 && (
                      <div className="text-xs opacity-60 truncate">
                        {session.messages[session.messages.length - 1]?.content.substring(0, 50)}...
                      </div>
                    )}
                  </div>

                  {/* Session Actions */}
                  <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    <div className="flex items-center space-x-1">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          exportSession(session.id);
                        }}
                        className="text-gray-400 hover:text-white p-1 rounded"
                        title="Export Session"
                      >
                        üì§
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          duplicateSession(session.id);
                        }}
                        className="text-gray-400 hover:text-white p-1 rounded"
                        title="Duplicate Session"
                      >
                        üìã
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          archiveSession(session.id);
                        }}
                        className="text-gray-400 hover:text-yellow-400 p-1 rounded"
                        title="Archive Session"
                      >
                        üìÅ
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          if (confirm('·Éú·Éê·Éõ·Éì·Éï·Éò·Éö·Éê·Éì ·Éí·É°·É£·É†·É° ·Éê·Éõ ·É©·Éê·É¢·Éò·É° ·É¨·Éê·É®·Éö·Éê?')) {
                            deleteSession(session.id);
                          }
                        }}
                        className="text-gray-400 hover:text-red-400 p-1 rounded"
                        title="Delete Session"
                      >
                        üóëÔ∏è
                      </button>
                    </div>
                  </div>
                </div>
              ))}

              {/* Archived Sessions Section */}
              {chatSessions.filter(s => s.isArchived).length > 0 && (
                <div className="border-t border-gray-600 pt-3 mt-4">
                  <h5 className="text-gray-400 text-xs font-medium mb-2 px-2">
                    üìÅ ·Éì·Éê·Éê·É†·É•·Éò·Éï·Éî·Éë·É£·Éö·Éò ·É©·Éê·É¢·Éî·Éë·Éò ({chatSessions.filter(s => s.isArchived).length})
                  </h5>
                  {chatSessions
                    .filter(session => session.isArchived)
                    .map((session) => (
                    <div
                      key={session.id}
                      className="p-2 rounded text-xs text-gray-500 hover:text-gray-400 hover:bg-gray-700/50 cursor-pointer transition-colors"
                      onClick={() => {
                        setCurrentSessionId(session.id);
                        setChatMessages(session.messages || []);
                      }}
                    >
                      <div className="flex justify-between items-center">
                        <span className="truncate">{session.title}</span>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setChatSessions(prev => prev.map(s => 
                              s.id === session.id ? { ...s, isArchived: false } : s
                            ));
                          }}
                          className="text-gray-500 hover:text-blue-400 ml-2"
                          title="Restore Session"
                        >
                          ‚Ü©Ô∏è
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </div>

        {/* Sidebar Footer */}
        <div className="p-3 border-t border-gray-700 bg-gray-750">
          <div className="text-xs text-gray-500 text-center">
            <div>üíæ Auto-saved ‚Ä¢ üîÑ Real-time sync</div>
            <div className="mt-1">
              WebSocket: <span className={`${getWebSocketStatus() === 'connected' ? 'text-green-400' : 'text-red-400'}`}>
                {getWebSocketStatus()}
              </span>
            </div>
          </div>
        </div>
      </div>

      {/* Main Chat Area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* File Context Section */}
        {fileContext.length > 0 && (
          <div className="p-3 border-b border-gray-700 bg-gray-750">
            <div className="text-xs text-gray-400 mb-2">üìé File Context:</div>
            <div className="flex flex-wrap gap-1">
              {fileContext.map((file) => (
                <div key={file} className="flex items-center bg-blue-600 text-white px-2 py-1 rounded text-xs">
                  <span>{file}</span>
                  <button
                    onClick={() => removeFileContext(file)}
                    className="ml-1 text-blue-200 hover:text-white"
                  >
                    √ó
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Edit Preview Modal */}
        {showEditPreview && pendingEditRequest && (
          <div className="p-3 border-b border-gray-700 bg-orange-900">
            <div className="text-sm text-orange-200 mb-2">üîß Edit Request Preview</div>
            <div className="bg-gray-800 p-2 rounded text-xs text-gray-300 mb-3">
              <pre className="whitespace-pre-wrap">{pendingEditRequest.preview || 'Preview generating...'}</pre>
            </div>
            <div className="flex gap-2">
              <button
                onClick={approveEditRequest}
                className="px-3 py-1 bg-green-600 text-white rounded text-xs hover:bg-green-700"
              >
                ‚úÖ Apply Changes
              </button>
              <button
                onClick={rejectEditRequest}
                className="px-3 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
              >
                ‚ùå Cancel
              </button>
            </div>
          </div>
        )}

        {/* üéØ PHASE 1: Enhanced Message Rendering with Georgian Support */}
        <div ref={chatContainerRef} className="flex-1 overflow-y-auto p-4">
          {chatMessages.map((message) => (
            <MessageRenderer
              key={message.id}
              content={message.content}
              type={message.type}
              timestamp={message.timestamp}
              isStreaming={message.isStreaming}
              formatted={message.formatted}
              memoryIntegrated={message.memoryIntegrated}
              contextAware={message.contextAware}
            />
          ))}
          {/* Enhanced Loading Indicator with MessageRenderer styling */}
          {isLoading && (
            <MessageRenderer
              content="ü§ñ ·Éí·É£·É†·É£·Éö·Éù ·É§·Éò·É•·É†·Éù·Éë·É° ·Éì·Éê ·Éó·É•·Éï·Éî·Éú·Éò ·Éô·Éò·Éó·ÉÆ·Éï·Éò·É° ·Éê·Éú·Éê·Éö·Éò·Éñ·É° ·Éê·ÉÆ·Éù·É†·É™·Éò·Éî·Éö·Éî·Éë·É°..."
              type="ai"
              timestamp={new Date().toISOString()}
              isStreaming={true}
            />
          )}
        </div>

        <div className="p-4 border-t border-gray-700">
          {/* File Context Input */}
          <div className="mb-3 p-2 bg-gray-750 rounded border border-gray-600">
            <div className="text-xs text-gray-400 mb-2">üìé Add File Context (Replit-style):</div>
            <div className="flex gap-2">
              <input
                type="text"
                value={newFileContext}
                onChange={(e) => setNewFileContext(e.target.value)}
                onKeyDown={(e) => e.key === "Enter" && addFileContext()}
                placeholder="File path (e.g., src/App.tsx)"
                className="flex-1 bg-gray-700 text-gray-200 px-2 py-1 rounded text-sm focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <button
                onClick={addFileContext}
                className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
              >
                ‚ûï
              </button>
            </div>
          </div>

          {/* Main Chat Input */}
          <div className="flex space-x-2">
            <input
              type="text"
              value={chatInput}
              onChange={(e) => setChatInput(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && sendMessage()}
              placeholder={`Ask Gurulo AI... (${assistantMode.toUpperCase()} mode)`}
              className="flex-1 bg-gray-700 text-gray-200 px-3 py-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
              disabled={isLoading}
            />
            <button
              onClick={sendMessage}
              disabled={isLoading || !chatInput.trim()}
              className={`px-3 py-2 rounded text-white transition-colors ${ 
                assistantMode === 'advanced' 
                  ? 'bg-orange-600 hover:bg-orange-500 disabled:bg-gray-600'
                  : 'bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600'
              }`}
            >
              <Send size={16} />
            </button>
          </div>

          {/* Mode Status */}
          <div className="mt-2 text-xs text-gray-500 text-center">
            {assistantMode === 'advanced' && (
              <span className="text-orange-400">‚ö° Advanced Mode: Code editing with diff preview</span>
            )}
            {assistantMode === 'basic' && (
              <span className="text-green-400">üü¢ Basic Mode: Explanations and recommendations</span>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}