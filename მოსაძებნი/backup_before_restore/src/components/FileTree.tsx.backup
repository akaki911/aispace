import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
  IconChevronRight,
  IconChevronDown,
  IconFile,
  IconFolder,
  IconFolderOpen,
  IconX,
  IconSearch,
  IconFileText,
  IconPhoto,
  IconFileCode,
  IconSettings,
  IconTerminal,
  IconDatabase,
  IconBrandReact,
  IconBrandJavascript,
  IconBrandTypescript,
  IconFileCode2,
  IconJson,
  IconMarkdown,
  IconRefresh,
  IconAlertTriangle,
  IconLoader2,
  IconCopy,
  IconCheck,
  IconPlus,
  IconUpload,
  IconFolderPlus,
  IconEdit,
  IconTrash,
  IconEye,
  IconEyeOff,
  IconPackage,
  IconGitBranch,
  IconDots,
  IconWand,
  IconDownload // Import for Download icon
} from '@tabler/icons-react';
import { Editor } from '@monaco-editor/react';
import classNames from 'classnames';
import { rateLimitManager } from '../utils/rateLimitHandler';
import AdvancedSearch from './AdvancedSearch';
import { enhancedSearchService } from '../services/enhancedSearchService';
import JSZip from 'jszip'; // Import JSZip

// Georgian text detection utility
const isGeorgianText = (text: string): boolean => {
  const georgianPattern = /[\u10A0-\u10FF]/;
  return georgianPattern.test(text);
};

// Simplified Georgian filename handling for better compatibility
const encodeForHeader = (text: string): string => {
  try {
    // For Georgian text, use simpler approach - just URL encode
    if (isGeorgianText(text)) {
      console.log('📁 Encoding Georgian filename:', text);
      // Use standard URL encoding for Georgian text
      return encodeURIComponent(text);
    }

    // For other text, use standard URL encoding
    return encodeURIComponent(text);
  } catch (e) {
    console.warn('Failed to encode text for header:', e);
    // Fallback: use the text as-is
    return text;
  }
};

// UTF-8 safe text decoding
const decodeUTF8 = (text: string): string => {
  try {
    if (isGeorgianText(text)) {
      return text; // Already properly decoded
    }
    return decodeURIComponent(escape(text));
  } catch (e) {
    return text;
  }
};

interface FileNode {
  name: string;
  path: string;
  type: 'file' | 'directory';
  children?: FileNode[];
  size?: number;
  lastModified?: string;
  isSystemFile?: boolean;
  isHidden?: boolean;
  category?: 'source' | 'config' | 'packager' | 'system' | 'other';
}

interface Tab {
  id: string;
  name: string;
  path: string;
  content?: string;
  formattedContent?: string;
  language?: string;
  isActive?: boolean;
  isLoading?: boolean;
  hasError?: boolean;
  errorMessage?: string;
  hasUnsavedChanges?: boolean;
  originalContent?: string;
}

interface FileTreeProps {
  className?: string;
}

interface ContextMenu {
  x: number;
  y: number;
  path: string;
  type: 'file' | 'directory';
  visible: boolean;
}

interface NewFileModalProps {
  isOpen: boolean;
  type: 'file' | 'folder';
  parentPath?: string;
  onClose: () => void;
  onConfirm: (name: string) => void;
}

const STORAGE_KEYS = {
  EXPANDED_FOLDERS: 'fileTree-expanded',
  OPEN_TABS: 'fileTree-tabs',
  ACTIVE_TAB: 'fileTree-activeTab'
};

// Enhanced file categorization
const categorizeFile = (fileName: string, isDirectory: boolean = false): 'source' | 'config' | 'packager' | 'system' | 'other' => {
  const fullName = fileName.toLowerCase();

  if (isDirectory) {
    const sourceDirectories = new Set([
      'src', 'ai', 'ai-service', 'backend', 'frontend', 'functions',
      'middleware', 'routes', 'scripts', 'docs', 'public', 'attached_assets',
      'logs', 'memory_data', 'memory_facts', 'groq_response_errors', 'components'
    ]);
    return sourceDirectories.has(fullName) ? 'source' : 'other';
  }

  // Packager files
  const packagerFiles = new Set([
    'package.json', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', '.upm'
  ]);
  if (packagerFiles.has(fullName) || fullName === 'node_modules') {
    return 'packager';
  }

  // Config files
  const configFiles = new Set([
    '.replit', '.gitignore', 'firebase.json', 'firestore.indexes.json',
    'firestore.rules', 'tsconfig.json', 'tsconfig.app.json', 'tsconfig.node.json',
    'vite.config.ts', 'tailwind.config.js', 'postcss.config.cjs', 'eslint.config.js',
    'index.html'
  ]);
  if (configFiles.has(fullName)) {
    return 'config';
  }

  // System files
  const systemFiles = new Set([
    '.env', '.env.example', 'readme.md', 'required_secrets.md',
    'replit_secrets_setup.md'
  ]);
  if (systemFiles.has(fullName) || fullName.includes('.env')) {
    return 'system';
  }

  return 'other';
};

// New File/Folder Modal Component
const NewFileModal: React.FC<NewFileModalProps> = ({ isOpen, type, parentPath, onClose, onConfirm }) => {
  const [name, setName] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (name.trim()) {
      onConfirm(name.trim());
      setName('');
      onClose();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-[#161b22] border border-[#30363d] rounded-lg p-6 w-96">
        <h3 className="text-lg font-semibold text-[#e6edf3] mb-4">
          შექმენი ახალი {type === 'file' ? 'ფაილი' : 'ფოლდერი'}
        </h3>
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-sm text-[#7d8590] mb-2">
              {type === 'file' ? 'ფაილის სახელი' : 'ფოლდერის სახელი'}
            </label>
            <input
              type="text"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder={type === 'file' ? 'example.txt' : 'new-folder'}
              className="w-full px-3 py-2 bg-[#0d1117] border border-[#30363d] rounded text-[#e6edf3] focus:outline-none focus:ring-2 focus:ring-[#58a6ff]"
              autoFocus
            />
            {parentPath && (
              <p className="text-xs text-[#7d8590] mt-1">
                მდებარეობა: {parentPath}/
              </p>
            )}
          </div>
          <div className="flex justify-end space-x-3">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 text-[#7d8590] hover:text-[#e6edf3] transition-colors"
            >
              გაუქმება
            </button>
            <button
              type="submit"
              disabled={!name.trim()}
              className="px-4 py-2 bg-[#238636] hover:bg-[#2ea043] disabled:opacity-50 disabled:cursor-not-allowed text-white rounded transition-colors"
            >
              შექმნა
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

const FileTree: React.FC<FileTreeProps> = ({ className }) => {
  const [fileTree, setFileTree] = useState<FileNode[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());
  const [openTabs, setOpenTabs] = useState<Tab[]>([]);
  const [activeTab, setActiveTab] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [contextMenu, setContextMenu] = useState<ContextMenu>({ x: 0, y: 0, path: '', type: 'file', visible: false });
  const [requestInProgress, setRequestInProgress] = useState(false);
  const [copiedToClipboard, setCopiedToClipboard] = useState(false);
  const [savingTabs, setSavingTabs] = useState<Set<string>>(new Set());
  const [savedTabs, setSavedTabs] = useState<Set<string>>(new Set());
  const [newFileModal, setNewFileModal] = useState<{ isOpen: boolean; type: 'file' | 'folder'; parentPath?: string }>({ isOpen: false, type: 'file' });
  const [dragOver, setDragOver] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [showAdvancedSearch, setShowAdvancedSearch] = useState(false);
  const [isDownloading, setIsDownloading] = useState(false); // State for download progress

  const abortControllerRef = useRef<AbortController | null>(null);
  const fileTreeRef = useRef<HTMLDivElement>(null);
  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const editorRef = useRef<any>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const folderInputRef = useRef<HTMLInputElement>(null);

  // Load persistent state from localStorage - only once on mount
  useEffect(() => {
    const loadStoredState = () => {
      try {
        const savedExpanded = localStorage.getItem(STORAGE_KEYS.EXPANDED_FOLDERS);
        if (savedExpanded) {
          const expandedArray = JSON.parse(savedExpanded);
          if (Array.isArray(expandedArray)) {
            setExpandedFolders(new Set(expandedArray));
          }
        }

        const savedTabs = localStorage.getItem(STORAGE_KEYS.OPEN_TABS);
        if (savedTabs) {
          const tabsArray = JSON.parse(savedTabs);
          if (Array.isArray(tabsArray)) {
            setOpenTabs(tabsArray);
          }
        }

        const savedActiveTab = localStorage.getItem(STORAGE_KEYS.ACTIVE_TAB);
        if (savedActiveTab) {
          setActiveTab(savedActiveTab);
        }
      } catch (e) {
        console.warn('Failed to load FileTree state from localStorage:', e);
        Object.values(STORAGE_KEYS).forEach(key => {
          localStorage.removeItem(key);
        });
      }
    };

    loadStoredState();
  }, []); // Empty dependency array - run only once

  // Debounced save to localStorage
  const debouncedSave = useCallback((key: string, value: any) => {
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
    }
    debounceTimeoutRef.current = setTimeout(() => {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch (e) {
        console.warn('Failed to save to localStorage:', e);
      }
    }, 300);
  }, []);

  // Save state to localStorage with debouncing
  useEffect(() => {
    const expandedArray = Array.from(expandedFolders);
    debouncedSave(STORAGE_KEYS.EXPANDED_FOLDERS, expandedArray);
  }, [expandedFolders, debouncedSave]);

  useEffect(() => {
    debouncedSave(STORAGE_KEYS.OPEN_TABS, openTabs);
  }, [openTabs, debouncedSave]);

  useEffect(() => {
    if (activeTab) {
      debouncedSave(STORAGE_KEYS.ACTIVE_TAB, activeTab);
    } else {
      localStorage.removeItem(STORAGE_KEYS.ACTIVE_TAB);
    }
  }, [activeTab, debouncedSave]);

  // Enhanced file icon system
  const getFileIcon = useCallback((fileName: string, isDirectory?: boolean) => {
    if (isDirectory) {
      return null;
    }

    const ext = fileName.toLowerCase().split('.').pop() || '';
    const fullName = fileName.toLowerCase();

    // Georgian files support
    if (isGeorgianText(fileName)) {
      return <IconFileText className="w-4 h-4 text-blue-400" />;
    }

    if (fullName === 'package.json' || fullName === 'package-lock.json') {
      return <IconPackage className="w-4 h-4 text-green-500" />;
    }

    if (fullName.includes('.env')) {
      return <IconSettings className="w-4 h-4 text-yellow-500" />;
    }

    if (fullName === 'tsconfig.json' || fullName === 'vite.config.ts') {
      return <IconSettings className="w-4 h-4 text-blue-500" />;
    }

    if (fullName === 'readme.md' || fullName === 'readme.txt') {
      return <IconFileText className="w-4 h-4 text-blue-400" />;
    }

    switch (ext) {
      case 'tsx':
        return <IconBrandReact className="w-4 h-4 text-cyan-400" />;
      case 'jsx':
        return <IconBrandReact className="w-4 h-4 text-blue-400" />;
      case 'ts':
        return <IconBrandTypescript className="w-4 h-4 text-blue-600" />;
      case 'js':
        return <IconBrandJavascript className="w-4 h-4 text-yellow-500" />;
      case 'json':
        return <IconJson className="w-4 h-4 text-orange-500" />;
      case 'md':
        return <IconMarkdown className="w-4 h-4 text-gray-300" />;
      case 'txt':
        return <IconFileText className="w-4 h-4 text-gray-400" />;
      case 'sh':
        return <IconTerminal className="w-4 h-4 text-green-500" />;
      case 'bash':
        return <IconTerminal className="w-4 h-4 text-green-500" />;
      case 'png':
      case 'jpg':
      case 'jpeg':
      case 'gif':
      case 'svg':
        return <IconPhoto className="w-4 h-4 text-pink-500" />;
      case 'sql':
        return <IconDatabase className="w-4 h-4 text-blue-600" />;
      case 'css':
        return <IconFileCode2 className="w-4 h-4 text-purple-500" />;
      case 'html':
        return <IconFileCode className="w-4 h-4 text-orange-600" />;
      case 'py':
        return <IconFileCode className="w-4 h-4 text-blue-500" />;
      default:
        return <IconFile className="w-4 h-4 text-gray-400" />;
    }
  }, []);

  // Enhanced language detection for Monaco Editor
  const getMonacoLanguage = useCallback((fileName: string): string => {
    const ext = fileName.toLowerCase().split('.').pop() || '';
    const fullName = fileName.toLowerCase();

    if (fullName.includes('dockerfile')) return 'dockerfile';
    if (fullName === '.gitignore') return 'ignore';
    if (fullName.includes('.env')) return 'shell';

    const languageMap: Record<string, string> = {
      'tsx': 'typescript',
      'jsx': 'javascript',
      'ts': 'typescript',
      'js': 'javascript',
      'json': 'json',
      'md': 'markdown',
      'sh': 'shell',
      'bash': 'shell',
      'sql': 'sql',
      'css': 'css',
      'scss': 'scss',
      'sass': 'sass',
      'less': 'less',
      'html': 'html',
      'htm': 'html',
      'xml': 'xml',
      'py': 'python',
      'yml': 'yaml',
      'yaml': 'yaml',
      'php': 'php',
      'java': 'java',
      'cpp': 'cpp',
      'c': 'c',
      'cs': 'csharp',
      'go': 'go',
      'rs': 'rust',
      'rb': 'ruby',
      'swift': 'swift',
      'kt': 'kotlin',
      'dart': 'dart'
    };

    return languageMap[ext] || 'plaintext';
  }, []);

  // Validate and transform node structure with enhanced categorization
  const validateAndTransformNode = useCallback((node: any): FileNode | null => {
    if (!node || typeof node !== 'object') {
      return null;
    }

    if (!node.name || typeof node.name !== 'string') {
      return null;
    }

    if (!node.path || typeof node.path !== 'string') {
      return null;
    }

    if (!node.type || (node.type !== 'file' && node.type !== 'directory')) {
      return null;
    }

    const isHidden = node.name.startsWith('.') || node.name.startsWith('_') ||
                     node.name === 'node_modules' || node.name === '.git';

    const systemFiles = ['.env', '.env.example', '.gitignore', '.replit', 'REQUIRED_SECRETS.md'];
    const isSystemFile = systemFiles.includes(node.name) || node.name.includes('.env');

    const category = categorizeFile(node.name, node.type === 'directory');

    const validatedNode: FileNode = {
      name: node.name,
      path: node.path,
      type: node.type,
      size: typeof node.size === 'number' ? node.size : undefined,
      lastModified: typeof node.lastModified === 'string' ? node.lastModified : undefined,
      isSystemFile,
      isHidden,
      category
    };

    if (node.type === 'directory' && Array.isArray(node.children)) {
      const validChildren = node.children
        .map(validateAndTransformNode)
        .filter((child): child is FileNode => child !== null);
      validatedNode.children = validChildren;
    }

    return validatedNode;
  }, []);

  // Load file tree with rate limiting and caching protection
  const loadFileTree = useCallback(async () => {
    if (requestInProgress) {
      console.warn('📂 FileTree: Request already in progress, skipping');
      return;
    }

    try {
      setRequestInProgress(true);
      setLoading(true);
      setError(null);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000);

      const response = await fetch('/api/files/tree', {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json; charset=utf-8',
          'Content-Type': 'application/json; charset=utf-8',
          'Cache-Control': 'no-cache'
        }
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
      }

      const data = await response.json();

      if (controller.signal.aborted) {
        throw new Error('Request aborted');
      }

      let processedTree: FileNode[] = [];

      if (data.success && data.tree) {
        processedTree = data.tree.map(validateAndTransformNode).filter((node): node is FileNode => node !== null);
        console.log('✅ File tree loaded successfully:', data.itemCount || 'unknown count');

        // Cache successful response
        localStorage.setItem('fileTree-cache', JSON.stringify(processedTree));
        localStorage.setItem('fileTree-timestamp', Date.now().toString());
      } else if (data && typeof data === 'object') {
        if (Array.isArray(data.files)) {
          processedTree = data.files.map(validateAndTransformNode).filter((node): node is FileNode => node !== null);
        } else if (Array.isArray(data.data)) {
          processedTree = data.data.map(validateAndTransformNode).filter((node): node is FileNode => node !== null);
        } else if (data.success && Array.isArray(data.tree)) {
          processedTree = data.tree.map(validateAndTransformNode).filter((node): node is FileNode => node !== null);
        }
      } else {
        throw new Error('Invalid file tree data received');
      }

      setFileTree(processedTree);

    } catch (err: any) {
      if (err.name === 'AbortError' || (err.message && err.message.includes('aborted'))) {
        setError('Request timed out or was aborted.');
        return;
      }

      console.error('❌ Failed to load file tree:', err);
      setError(err.message);

      // Try to load from cache first
      const cachedTree = localStorage.getItem('fileTree-cache');
      const cacheTimestamp = localStorage.getItem('fileTree-timestamp');
      const isCacheValid = cacheTimestamp && (Date.now() - parseInt(cacheTimestamp)) < 300000; // 5 minutes

      if (cachedTree && isCacheValid) {
        try {
          setFileTree(JSON.parse(cachedTree));
          console.log('📱 Loaded file tree from cache');
          return;
        } catch (parseError) {
          console.error('❌ Failed to parse cached file tree:', parseError);
        }
      }

      // Set fallback file tree structure
      setFileTree([
        {
          name: 'workspace',
          type: 'directory',
          children: [
            {
              name: 'src',
              type: 'directory',
              children: [
                { name: 'components', type: 'directory', children: [] },
                { name: 'pages', type: 'directory', children: [] },
                { name: 'hooks', type: 'directory', children: [] }
              ]
            },
            {
              name: 'backend',
              type: 'directory',
              children: [
                { name: 'routes', type: 'directory', children: [] },
                { name: 'services', type: 'directory', children: [] }
              ]
            },
            {
              name: 'ai-service',
              type: 'directory',
              children: [
                { name: 'routes', type: 'directory', children: [] },
                { name: 'services', type: 'directory', children: [] }
              ]
            }
          ]
        }
      ]);
    } finally {
      setLoading(false);
      setRequestInProgress(false);
    }
  }, []);

  // Load file content with simplified Georgian support
  const loadFileContent = useCallback(async (filePath: string, signal?: AbortSignal): Promise<{ content: string; formattedContent?: string; error?: string }> => {
    try {
      console.log('📁 Loading file content for:', filePath);

      // Use direct path for Georgian files, encoded path for others
      let requestPath = filePath;
      if (!isGeorgianText(filePath)) {
        requestPath = encodeForHeader(filePath);
      }

      console.log('📁 Request path:', requestPath);

      const response = await fetch(`/api/files/content/${requestPath}`, {
        signal,
        headers: {
          'Accept': 'text/plain; charset=utf-8, application/javascript, application/typescript, */*',
          'Content-Type': 'application/json; charset=utf-8'
        }
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        console.error('📁 File load error:', response.status, errorText);

        if (isGeorgianText(filePath)) {
          return {
            content: '',
            error: `ქართული ფაილის ჩატვირთვის შეცდომა: ${response.status} - ${errorText}`
          };
        }

        throw new Error(`Failed to load file: ${response.status} ${response.statusText} - ${errorText}`);
      }

      const content = await response.text();
      console.log('📁 File content loaded successfully, length:', content.length);

      if (!content.trim()) {
        return { content, error: 'File is empty' };
      }

      return { content, formattedContent: content };

    } catch (err: any) {
      if (err.name === 'AbortError') {
        return { content: '', error: 'Request cancelled' };
      }

      console.error('📖 FileTree: Failed to load file content:', err);

      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      return {
        content: '',
        error: `Error loading file: ${errorMessage}`
      };
    }
  }, []);

  // Enhanced file sorting with improved categories - stable with useCallback
  const sortAndGroupNodes = useCallback((nodes: FileNode[]): FileNode[] => {
    const safeNodes = Array.isArray(nodes) ? nodes : [];

    // Show all files - no filtering based on hidden status
    const filteredNodes = safeNodes;

    // Group nodes by category with visual separators
    const groups: { [key: string]: FileNode[] } = {
      source: [],      // Source directories first
      packager: [],    // Package files
      config: [],      // Config files
      other: [],       // Other files
      system: []       // System/secrets files last
    };

    filteredNodes.forEach(node => {
      const category = node.category || 'other';
      groups[category].push(node);
    });

    // Sort within each group
    Object.keys(groups).forEach(category => {
      groups[category].sort((a, b) => {
        if (a.type !== b.type) {
          return a.type === 'directory' ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });
    });

    // Combine groups in desired order with visual separation
    return [
      ...groups.source,      // Source directories first
      ...groups.packager,    // Package files
      ...groups.config,      // Config files
      ...groups.other,       // Other files
      ...groups.system       // System/secrets files last
    ];
  }, []); // Empty deps - function is pure and stable

  // Toggle folder expansion
  const toggleFolder = useCallback((folderPath: string) => {
    setExpandedFolders(prev => {
      const newSet = new Set(prev);
      if (newSet.has(folderPath)) {
        newSet.delete(folderPath);
      } else {
        newSet.add(folderPath);
      }
      return newSet;
    });
  }, []);

  // Open file in new tab with proper abort handling
  const openFile = useCallback(async (filePath: string, fileName: string) => {
    setSelectedFile(filePath);

    const existingTab = openTabs.find(tab => tab.path === filePath);
    if (existingTab) {
      setActiveTab(existingTab.id);
      return;
    }

    const tabId = `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const newTab: Tab = {
      id: tabId,
      name: fileName,
      path: filePath,
      language: getMonacoLanguage(fileName),
      isActive: true,
      isLoading: true,
      hasError: false,
      hasUnsavedChanges: false
    };

    setOpenTabs(prev => [...prev, newTab]);
    setActiveTab(tabId);

    const fileAbortController = new AbortController();

    try {
      const result = await loadFileContent(filePath, fileAbortController.signal);

      setOpenTabs(prev => {
        const tabExists = prev.some(tab => tab.id === tabId);
        if (!tabExists) {
          return prev;
        }

        return prev.map(tab =>
          tab.id === tabId ? {
            ...tab,
            content: result.content,
            formattedContent: result.formattedContent,
            originalContent: result.content, // Store original for change detection
            isLoading: false,
            hasError: !!result.error,
            errorMessage: result.error
          } : tab
        );
      });
    } catch (err: any) {
      if (err.name === 'AbortError') {
        return;
      }

      setOpenTabs(prev => prev.map(tab =>
        tab.id === tabId ? {
          ...tab,
          content: '',
          isLoading: false,
          hasError: true,
          errorMessage: err.message || 'Failed to load file content'
        } : tab
      ));
    }
  }, [openTabs, loadFileContent, getMonacoLanguage]);

  // Close tab
  const closeTab = useCallback((tabId: string, e?: React.MouseEvent) => {
    if (e) {
      e.stopPropagation();
    }

    setOpenTabs(prev => {
      const newTabs = prev.filter(tab => tab.id !== tabId);

      if (activeTab === tabId) {
        const currentIndex = prev.findIndex(tab => tab.id === tabId);
        if (newTabs.length > 0) {
          const nextTab = newTabs[currentIndex] || newTabs[currentIndex - 1] || newTabs[0];
          setActiveTab(nextTab.id);
          setSelectedFile(nextTab.path);
        } else {
          setActiveTab(null);
          setSelectedFile(null);
        }
      }

      return newTabs;
    });
  }, [activeTab]);

  // Enhanced save file content with improved feedback
  const saveFileContent = useCallback(async (filePath: string, content: string) => {
    const tabToSave = openTabs.find(tab => tab.path === filePath);
    if (!tabToSave) return;

    const saveAbortController = new AbortController();

    try {
      setSavingTabs(prev => new Set([...prev, tabToSave.id]));

      // Use enhanced encoding for Georgian text
      const encodedPath = encodeForHeader(filePath);
      let contentToSave = content;

      if (isGeorgianText(content) || isGeorgianText(filePath)) {
        // Keep content as UTF-8, just ensure proper headers
        contentToSave = content;
      }

      const response = await fetch(`/api/files/content/${encodedPath}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
          content: contentToSave
        }),
        signal: saveAbortController.signal
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        throw new Error(`Failed to save file: ${response.status} ${response.statusText} - ${errorText}`);
      }

      // Update tab state - no longer has unsaved changes
      setOpenTabs(prev => prev.map(tab =>
        tab.path === filePath ? {
          ...tab,
          hasUnsavedChanges: false,
          content: content,
          originalContent: content // Update original content
        } : tab
      ));

      setSavingTabs(prev => {
        const newSet = new Set(prev);
        newSet.delete(tabToSave.id);
        return newSet;
      });

      // Show green success indicator
      setSavedTabs(prev => new Set([...prev, tabToSave.id]));

      setTimeout(() => {
        setSavedTabs(prev => {
          const newSet = new Set(prev);
          newSet.delete(tabToSave.id);
          return newSet;
        });
      }, 2000); // Shorter feedback duration

    } catch (error: any) {
      if (error.name === 'AbortError') {
        return;
      }

      setSavingTabs(prev => {
        const newSet = new Set(prev);
        newSet.delete(tabToSave.id);
        return newSet;
      });

      alert(`Failed to save ${filePath}: ${error.message}`);
      throw error;
    }
  }, [openTabs]);

  // New file/folder creation
  const createNewItem = useCallback(async (name: string, type: 'file' | 'folder', parentPath: string = '') => {
    try {
      const fullPath = parentPath ? `${parentPath}/${name}` : name;
      const encodedPath = encodeForHeader(fullPath);

      const response = await fetch('/api/files/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
        },
        body: JSON.stringify({
          path: encodedPath,
          type: type,
          content: type === 'file' ? '' : undefined
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to create ${type}`);
      }

      // Refresh file tree
      loadFileTree();

      // If it's a file, open it in a new tab
      if (type === 'file') {
        setTimeout(() => openFile(fullPath, name), 500);
      }

    } catch (error: any) {
      alert(`Failed to create ${type}: ${error.message}`);
    }
  }, [loadFileTree, openFile]);

  // Enhanced file upload handling
  const handleFileUpload = useCallback(async (files: FileList) => {
    setUploading(true);

    try {
      const formData = new FormData();

      for (let i = 0; i < files.length; i++) {
        formData.append('files', files[i]);
      }

      const response = await fetch('/api/files/upload', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error('Failed to upload files');
      }

      // Refresh file tree
      loadFileTree();

    } catch (error: any) {
      alert(`Failed to upload files: ${error.message}`);
    } finally {
      setUploading(false);
    }
  }, [loadFileTree]);

  // Drag and drop handlers
  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setDragOver(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setDragOver(false);
  }, []);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setDragOver(false);

    if (e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files);
    }
  }, [handleFileUpload]);

  // Copy to clipboard
  const copyToClipboard = useCallback(() => {
    const activeTabContent = openTabs.find(tab => tab.id === activeTab);
    if (!activeTabContent?.content) return;

    try {
      navigator.clipboard.writeText(activeTabContent.formattedContent || activeTabContent.content);
      setCopiedToClipboard(true);
      setTimeout(() => setCopiedToClipboard(false), 2000);
    } catch (err) {
      console.error('Failed to copy to clipboard:', err);
    }
  }, [activeTab, openTabs]);

  // Download as ZIP functionality
  const downloadAsZip = useCallback(async () => {
    if (isDownloading) return;

    try {
      setIsDownloading(true);
      console.log('📦 Starting ZIP download...');

      const zip = new JSZip();
      let filesProcessed = 0;
      let filesTotal = 0;

      // Count total files
      const countFiles = (items: any[]): number => {
        let count = 0;
        items.forEach(item => {
          if (item.type === 'file') {
            count++;
          } else if (item.type === 'directory' && item.children) {
            count += countFiles(item.children);
          }
        });
        return count;
      };

      filesTotal = countFiles(fileTree); // Use fileTree state here
      console.log(`📊 Total files to process: ${filesTotal}`);

      // Add files to ZIP recursively
      const addFilesToZip = async (items: any[], basePath: string = '') => {
        for (const item of items) {
          if (item.type === 'file') {
            try {
              // Ensure we use the correct path for fetching content
              const fetchPath = item.path; 
              const response = await fetch(`/api/files/content/${encodeForHeader(fetchPath)}`, {
                headers: {
                  'Content-Type': 'application/json'
                }
              });

              if (response.ok) {
                const content = await response.text();
                const filePath = basePath ? `${basePath}/${item.name}` : item.name;
                zip.file(filePath, content);
                filesProcessed++;
                console.log(`✅ Added: ${filePath} (${filesProcessed}/${filesTotal})`);
              } else {
                console.warn(`⚠️ Could not fetch: ${item.path}`);
              }
            } catch (error) {
              console.warn(`⚠️ Error processing file ${item.path}:`, error);
            }
          } else if (item.type === 'directory' && item.children) {
            const dirPath = basePath ? `${basePath}/${item.name}` : item.name;
            await addFilesToZip(item.children, dirPath);
          }
        }
      };

      await addFilesToZip(fileTree); // Use fileTree state here

      console.log('🔄 Generating ZIP file...');
      const zipBlob = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });

      // Create download link
      const url = URL.createObjectURL(zipBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `gurulo-project-${new Date().toISOString().split('T')[0]}.zip`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      console.log(`✅ ZIP download complete! ${filesProcessed} files processed`);
      setShowMenu(false); // Close context menu after download

    } catch (error) {
      console.error('❌ ZIP download failed:', error);
      setError('ZIP ჩამოტვირთვა ვერ მოხერხდა');
    } finally {
      setIsDownloading(false);
    }
  }, [fileTree, isDownloading]); // Added fileTree to dependencies

  // Initial load - run only once
  useEffect(() => {
    // Small delay to prevent double loading in React strict mode
    const timeoutId = setTimeout(() => {
      loadFileTree();
    }, 100);

    // Add periodic refresh
    const refreshInterval = setInterval(loadFileTree, 60000); // Refresh every minute

    return () => {
      clearTimeout(timeoutId);
      clearInterval(refreshInterval); // Clear the interval on unmount
      if (abortControllerRef.current) {
        try {
          abortControllerRef.current.abort('Component unmounting');
        } catch (err) {
          // Ignore abort errors during cleanup
        }
      }
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
    };
  }, []); // Empty dependency array ensures this runs only once

  // Enhanced file filtering with direct file matching
  const filteredFileTree = useMemo(() => {
    const safeFileTree = Array.isArray(fileTree) ? fileTree : [];

    if (!searchQuery.trim()) {
      return sortAndGroupNodes(safeFileTree);
    }

    const query = searchQuery.toLowerCase();
    const matchedFiles: FileNode[] = [];

    // Recursively find all matching files
    const findMatchingFiles = (nodes: FileNode[], parentPath: string = '') => {
      if (!Array.isArray(nodes)) return;

      nodes.forEach(node => {
        if (!node || typeof node !== 'object') return;

        const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;

        if (node.type === 'file') {
          // Check if file name or full path contains search query
          if (node.name?.toLowerCase().includes(query) || currentPath.toLowerCase().includes(query)) {
            matchedFiles.push({
              ...node,
              path: node.path || currentPath // Ensure path is available for display
            });
          }
        } else if (node.children && Array.isArray(node.children)) {
          // Recursively search in subdirectories
          findMatchingFiles(node.children, currentPath);
        }
      });
    };

    findMatchingFiles(safeFileTree);

    // Return matched files sorted by relevance
    return matchedFiles.sort((a, b) => {
      // Files with exact name matches first
      const aExactMatch = a.name?.toLowerCase() === query;
      const bExactMatch = b.name?.toLowerCase() === query;

      if (aExactMatch && !bExactMatch) return -1;
      if (!aExactMatch && bExactMatch) return 1;

      // Then by name similarity
      return a.name?.localeCompare(b.name || '') || 0;
    });
  }, [fileTree, searchQuery, sortAndGroupNodes]); // Include sortAndGroupNodes in deps

  // Context menu handlers
  const handleContextMenu = useCallback((e: React.MouseEvent, path: string, type: 'file' | 'directory') => {
    e.preventDefault();
    setContextMenu({
      x: e.clientX,
      y: e.clientY,
      path,
      type,
      visible: true
    });
  }, []);

  const hideContextMenu = useCallback(() => {
    setContextMenu(prev => ({ ...prev, visible: false }));
  }, []);

  // Click outside to hide context menu
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (contextMenu.visible) {
        hideContextMenu();
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, [contextMenu.visible, hideContextMenu]);

  // Enhanced keyboard navigation
  useEffect(() => {
    const handleKeydown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        const activeTabContent = openTabs.find(tab => tab.id === activeTab);
        if (activeTabContent?.hasUnsavedChanges && !savingTabs.has(activeTabContent.id)) {
          saveFileContent(activeTabContent.path, activeTabContent.content || '');
        }
        return;
      }

      if (!fileTreeRef.current?.contains(document.activeElement)) {
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        document.querySelector<HTMLInputElement>('#file-search-input')?.focus();
      }

      if (e.key === 'Escape') {
        setSearchQuery('');
      }
    };

    window.addEventListener('keydown', handleKeydown);
    return () => window.removeEventListener('keydown', handleKeydown);
  }, [activeTab, openTabs, savingTabs, saveFileContent]);

  // Handle editor content changes with unsaved detection
  const handleEditorChange = useCallback((value: string | undefined) => {
    if (!activeTab || !value) return;

    setOpenTabs(prev => prev.map(tab => {
      if (tab.id === activeTab) {
        const hasChanges = tab.originalContent !== value;
        return {
          ...tab,
          content: value,
          formattedContent: value,
          hasUnsavedChanges: hasChanges
        };
      }
      return tab;
    }));
  }, [activeTab]);

  // Enhanced Monaco Editor setup
  const handleEditorDidMount = useCallback((editor: any, monaco: any) => {
    editorRef.current = editor;

    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, async () => {
      const activeTabContent = openTabs.find(tab => tab.id === activeTab);
      if (activeTabContent?.content && activeTabContent.hasUnsavedChanges && !savingTabs.has(activeTabContent.id)) {
        try {
          await saveFileContent(activeTabContent.path, activeTabContent.content);
        } catch (error) {
          console.error('💾 Failed to save via keyboard shortcut:', error);
        }
      }
    });

    monaco.editor.defineTheme('replit-dark', {
      base: 'vs-dark',
      inherit: true,
      rules: [
        { token: 'comment', foreground: '6a9955', fontStyle: 'italic' },
        { token: 'keyword', foreground: '569cd6', fontStyle: 'bold' },
        { token: 'string', foreground: 'ce9178' },
        { token: 'number', foreground: 'b5cea8' },
        { token: 'type', foreground: '4ec9b0', fontStyle: 'bold' },
        { token: 'function', foreground: 'dcdcaa', fontStyle: 'bold' },
        { token: 'variable', foreground: '9cdcfe' },
        { token: 'constant', foreground: '4fc1ff', fontStyle: 'bold' },
      ],
      colors: {
        'editor.background': '#0d1117',
        'editor.foreground': '#e6edf3',
        'editor.lineHighlightBackground': '#161b22',
        'editorLineNumber.foreground': '#7d8590',
        'editorCursor.foreground': '#79c0ff',
      }
    });

    monaco.editor.setTheme('replit-dark');
  }, [activeTab, openTabs, savingTabs, saveFileContent]);

  // Get category separator for visual grouping
  const getCategorySeparator = useCallback((node: FileNode, index: number, nodes: FileNode[]) => {
    if (index === 0) return null;

    const currentCategory = node.category;
    const previousCategory = nodes[index - 1]?.category;

    if (currentCategory !== previousCategory) {
      const categoryLabels = {
        source: '📁 Source Directories',
        packager: '📦 Package Files',
        config: '⚙️ Configuration',
        other: '📄 Files',
        system: '🔒 System & Secrets'
      };

      return (
        <div key={`separator-${currentCategory}`} className="px-2 py-1 border-t border-[#21262d] mt-1 mb-1">
          <span className="text-xs text-[#7d8590] font-medium">
            {categoryLabels[currentCategory as keyof typeof categoryLabels] || '📄 Other Files'}
          </span>
        </div>
      );
    }

    return null;
  }, []);

  // Render file tree node with enhanced categorization
  const renderNode = useCallback((node: FileNode, level: number = 0) => {
    if (!node || typeof node !== 'object') {
      return null;
    }

    const isExpanded = expandedFolders.has(node.path);
    const isSelected = selectedFile === node.path;

    if (node.type === 'directory') {
      return (
        <div key={node.path} className="select-none">
          <div
            className={classNames(
              'flex items-center py-1.5 px-2 cursor-pointer rounded-md transition-all duration-200 group',
              {
                'bg-[#21262d] text-[#e6edf3]': isSelected,
                'text-[#e6edf3] hover:bg-[#161b22]': !isSelected
              }
            )}
            style={{ paddingLeft: `${level * 16 + 8}px` }}
            onClick={() => toggleFolder(node.path)}
            onContextMenu={(e) => handleContextMenu(e, node.path, 'directory')}
          >
            <div className={classNames(
              'flex items-center transition-transform duration-200 mr-1',
              { 'rotate-90': isExpanded }
            )}>
              <IconChevronRight className="w-4 h-4 text-[#7d8590]" />
            </div>
            {isExpanded ? (
              <IconFolderOpen className="w-4 h-4 text-[#58a6ff] mr-2" />
            ) : (
              <IconFolder className="w-4 h-4 text-[#58a6ff] mr-2" />
            )}
            <span className="text-sm truncate font-medium">
              {node.name}
            </span>
          </div>

          {isExpanded && node.children && Array.isArray(node.children) && (
            <div className="transition-all duration-300 ease-in-out overflow-hidden">
              {sortAndGroupNodes(node.children).map(child => renderNode(child, level + 1))}
            </div>
          )}
        </div>
      );
    } else {
      return (
        <div
          key={node.path}
          className={classNames(
            'flex items-center py-1.5 px-2 cursor-pointer rounded-md transition-colors group',
            {
              'bg-[#21262d] text-[#e6edf3]': isSelected,
              'text-[#e6edf3] hover:bg-[#161b22]': !isSelected
            }
          )}
          style={{ paddingLeft: `${level * 16 + 24}px` }}
          onClick={() => openFile(node.path, node.name)}
          onContextMenu={(e) => handleContextMenu(e, node.path, 'file')}
          title={`${node.path}${node.size ? ` (${formatFileSize(node.size)})` : ''}`}
        >
          <div className="flex-shrink-0">
            {getFileIcon(node.name)}
          </div>
          <span className={classNames(
            "text-sm truncate ml-2",
            {
              "text-[#e6edf3] font-medium": !node.isSystemFile,
              "text-[#79c0ff] font-semibold": node.isSystemFile
            }
          )}>
            {node.name}
          </span>
          {node.isSystemFile && (
            <IconSettings className="w-3 h-3 text-[#58a6ff] ml-1" title="სისტემური ფაილი" />
          )}
          {node.name === 'package.json' && (
            <IconPackage className="w-3 h-3 text-[#f97316] ml-1" title="Package file" />
          )}
          {node.name.startsWith('.git') && (
            <IconGitBranch className="w-3 h-3 text-[#f97316] ml-1" title="Git file" />
          )}
          {node.size && (
            <span className="text-xs text-[#7d8590] ml-auto opacity-0 group-hover:opacity-100 transition-opacity">
              {formatFileSize(node.size)}
            </span>
          )}
        </div>
      );
    }
  }, [expandedFolders, selectedFile, toggleFolder, openFile, getFileIcon, handleContextMenu, sortAndGroupNodes]);

  // Format file size
  const formatFileSize = useCallback((bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }, []);

  // Get active tab content
  const activeTabContent = useMemo(() => {
    if (!activeTab) return null;
    return openTabs.find(tab => tab.id === activeTab) || null;
  }, [activeTab, openTabs]);

  const safeFilteredTree = Array.isArray(filteredFileTree) ? filteredFileTree : [];

  if (loading) {
    return (
      <div className={classNames('flex flex-col h-full bg-[#0d1117] text-[#e6edf3]', className)}>
        <div className="p-3 border-b border-[#21262d]">
          <div className="animate-pulse bg-[#21262d] rounded h-10"></div>
        </div>
        <div className="p-2 space-y-2">
          {[...Array(8)].map((_, i) => (
            <div key={i} className="flex items-center space-x-2">
              <div className="w-4 h-4 bg-[#21262d] rounded animate-pulse"></div>
              <div className="w-4 h-4 bg-[#21262d] rounded animate-pulse"></div>
              <div className={`h-4 bg-[#21262d] rounded animate-pulse`} style={{ width: `${Math.random() * 120 + 80}px` }}></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className={classNames('flex flex-col h-full bg-[#0d1117] text-[#e6edf3]', className)}>
      {/* Error Banner */}
      {error && (
        <div className="bg-[#2d1b1b] border-b border-[#f85149] p-3">
          <div className="flex items-center space-x-2">
            <IconAlertTriangle className="w-4 h-4 text-[#f85149]" />
            <div className="flex-1">
              <p className="text-sm text-[#f85149] font-medium">Failed to load file tree</p>
              <p className="text-xs text-[#f85149] opacity-80">{error}</p>
            </div>
            <button
              onClick={() => {
                setError(null);
                loadFileTree();
              }}
              disabled={requestInProgress}
              className="inline-flex items-center space-x-1 px-3 py-1 bg-[#f85149] hover:bg-[#d73a49] disabled:opacity-50 text-white rounded text-xs transition-colors"
            >
              <IconRefresh className={classNames('w-3 h-3', { 'animate-spin': requestInProgress })} />
              <span>{requestInProgress ? 'Retrying...' : 'Retry'}</span>
            </button>
          </div>
        </div>
      )}

      <div className="flex flex-1 min-h-0">
        {/* File Tree Panel - Responsive Width */}
        <div
          className={classNames(
            "w-72 sm:w-80 md:w-64 lg:w-72 xl:w-80 border-r border-[#21262d] bg-[#0d1117] flex flex-col transition-colors min-w-0 flex-shrink-0",
            { 'ring-2 ring-[#58a6ff] ring-opacity-50': dragOver }
          )}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
        >
          {/* Toolbar */}
          <div className="p-3 border-b border-[#21262d] space-y-3">
            {/* Search Bar - Enhanced */}
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <div className="relative flex-1 mr-2">
                  <IconSearch className="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-[#7d8590]" />
                  <input
                    id="file-search-input"
                    type="text"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    placeholder="Search files... (Ctrl+P)"
                    className="w-full pl-10 pr-4 py-2 border border-[#30363d] rounded-md bg-[#161b22] text-[#e6edf3] text-sm focus:outline-none focus:ring-2 focus:ring-[#58a6ff] focus:border-[#58a6ff] placeholder-[#7d8590]"
                  />
                  {searchQuery && (
                    <button
                      onClick={() => setSearchQuery('')}
                      className="absolute right-3 top-1/2 transform -translate-y-1/2 text-[#7d8590] hover:text-[#e6edf3]"
                    >
                      <IconX className="w-4 h-4" />
                    </button>
                  )}
                </div>

                {/* Advanced Search Toggle */}
                <button
                  onClick={() => setShowAdvancedSearch(!showAdvancedSearch)}
                  className={`flex items-center space-x-1 px-2 py-1 text-xs rounded transition-colors ${
                    showAdvancedSearch
                      ? 'bg-[#58a6ff]/20 text-[#58a6ff] border border-[#58a6ff]/30'
                      : 'bg-[#21262d] text-[#7d8590] hover:bg-[#30363d] hover:text-[#e6edf3]'
                  }`}
                  title="Advanced search with fuzzy matching, content search, and filters"
                >
                  <IconWand className="w-3 h-3" />
                  <span className="hidden sm:inline">Advanced</span>
                </button>
              </div>

              {/* Advanced Search Component */}
              {showAdvancedSearch && (
                <div className="border border-[#30363d] rounded-lg overflow-hidden">
                  <AdvancedSearch
                    onFileSelect={(filePath) => {
                      handleFileSelect(filePath);
                      setShowAdvancedSearch(false);
                    }}
                    className="border-0"
                  />
                </div>
              )}
            </div>

            {/* Action Buttons - Responsive Layout */}
            <div className="flex flex-col gap-2">
              {/* First Row - Main Actions */}
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-1 flex-wrap">
                  <button
                    onClick={() => setNewFileModal({ isOpen: true, type: 'file' })}
                    className="flex items-center space-x-1 px-2 py-1 text-xs bg-[#238636] hover:bg-[#2ea043] text-white rounded transition-colors min-w-0 flex-shrink-0"
                    title="ახალი ფაილი"
                  >
                    <IconPlus className="w-3 h-3" />
                    <span className="hidden sm:inline">File</span>
                  </button>

                  <button
                    onClick={() => setNewFileModal({ isOpen: true, type: 'folder' })}
                    className="flex items-center space-x-1 px-2 py-1 text-xs bg-[#1f6feb] hover:bg-[#388bfd] text-white rounded transition-colors min-w-0 flex-shrink-0"
                    title="ახალი ფოლდერი"
                  >
                    <IconFolderPlus className="w-3 h-3" />
                    <span className="hidden sm:inline">Folder</span>
                  </button>

                  <button
                    onClick={() => fileInputRef.current?.click()}
                    disabled={uploading}
                    className="flex items-center space-x-1 px-2 py-1 text-xs bg-[#6f42c1] hover:bg-[#8a63d2] disabled:opacity-50 text-white rounded transition-colors min-w-0 flex-shrink-0"
                    title="ფაილების ატვირთვა"
                  >
                    {uploading ? (
                      <IconLoader2 className="w-3 h-3 animate-spin" />
                    ) : (
                      <IconUpload className="w-3 h-3" />
                    )}
                    <span className="hidden sm:inline">Upload</span>
                  </button>

                  {/* Refresh Button */}
                  <button
                    onClick={loadFileTree}
                    disabled={requestInProgress}
                    className="flex items-center space-x-1 px-2 py-1 text-xs bg-[#7d8590] hover:bg-[#8b949e] disabled:opacity-50 text-white rounded transition-colors min-w-0 flex-shrink-0"
                    title="განახლება"
                  >
                    <IconRefresh className={classNames('w-3 h-3', { 'animate-spin': requestInProgress })} />
                  </button>
                </div>
              </div>
            </div>
          </div>

          {/* File Tree with category separators */}
          <div ref={fileTreeRef} className="flex-1 overflow-auto p-2 space-y-1" tabIndex={0}>
            {safeFilteredTree.length === 0 ? (
              <div className="text-center py-8 text-[#7d8590]">
                <IconFolder className="w-8 h-8 mx-auto mb-2 text-[#30363d]" />
                <p className="text-sm">
                  {searchQuery ? 'No files found' : error ? 'Unable to load files' : 'No files available'}
                </p>
                {error && (
                  <button
                    onClick={loadFileTree}
                    disabled={requestInProgress}
                    className="mt-2 text-xs text-[#58a6ff] hover:text-[#79c0ff] disabled:opacity-50"
                  >
                    {requestInProgress ? 'Loading...' : 'Try again'}
                  </button>
                )}
              </div>
            ) : searchQuery.trim() ? (
              // Search results view - show files with full paths
              <div className="space-y-1">
                <div className="text-xs text-[#7d8590] px-2 py-1 border-b border-[#21262d] mb-2">
                  Found {safeFilteredTree.length} file{safeFilteredTree.length !== 1 ? 's' : ''} matching "{searchQuery}"
                </div>
                {safeFilteredTree.map((node) => (
                  <div
                    key={node.path}
                    className={classNames(
                      'flex items-center py-2 px-3 cursor-pointer rounded-md transition-colors group hover:bg-[#161b22]',
                      {
                        'bg-[#21262d] text-[#e6edf3]': selectedFile === node.path,
                        'text-[#e6edf3]': selectedFile !== node.path
                      }
                    )}
                    onClick={() => openFile(node.path, node.name)}
                    title={`Open ${node.path}`}
                  >
                    <div className="flex-shrink-0">
                      {getFileIcon(node.name)}
                    </div>
                    <div className="ml-3 flex flex-col min-w-0 flex-1">
                      <span className="text-sm font-medium truncate">
                        {node.name}
                      </span>
                      <span className="text-xs text-[#7d8590] truncate">
                        {node.path}
                      </span>
                    </div>
                    <div className="ml-2 opacity-0 group-hover:opacity-100 transition-opacity">
                      <span className="text-xs text-[#7d8590]">
                        {node.size ? formatFileSize(node.size) : ''}
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              // Normal tree view
              safeFilteredTree.map((node, index) => (
                <React.Fragment key={node.path}>
                  {getCategorySeparator(node, index, safeFilteredTree)}
                  {renderNode(node)}
                </React.Fragment>
              ))
            )}
          </div>
        </div>

        {/* File Viewer */}
        <div className="flex-1 flex flex-col bg-[#0d1117]">
          {/* Tabs */}
          {openTabs.length > 0 && (
            <div className="flex items-center bg-[#0d1117] border-b border-[#21262d] overflow-x-auto scrollbar-thin scrollbar-thumb-gray-600">
              <div className="flex min-w-0">
                {openTabs.map(tab => (
                  <div
                    key={tab.id}
                    className={classNames(
                      'flex items-center px-4 py-3 border-r border-[#21262d] cursor-pointer min-w-0 max-w-48 group transition-all duration-200 relative',
                      {
                        'bg-[#161b22] border-b-2 border-[#58a6ff] text-[#e6edf3]': activeTab === tab.id,
                        'bg-[#0d1117] text-[#7d8590] hover:bg-[#161b22] hover:text-[#e6edf3]': activeTab !== tab.id
                      }
                    )}
                    onClick={() => {
                      setActiveTab(tab.id);
                      setSelectedFile(tab.path);
                    }}
                  >
                    <div className="flex-shrink-0">
                      {getFileIcon(tab.name)}
                    </div>
                    <span className="ml-2 text-sm truncate font-medium" title={tab.name}>
                      {tab.name}
                      {/* Enhanced save status indicators */}
                      {tab.hasUnsavedChanges && !savingTabs.has(tab.id) && !savedTabs.has(tab.id) && (
                        <span
                          className="ml-1 text-red-400 font-bold animate-pulse"
                          title="შეუნახავი ცვლილებები"
                          style={{ fontSize: '10px' }}
                        >
                          ●
                        </span>
                      )}
                    </span>
                    {tab.hasError && (
                      <IconAlertTriangle className="ml-1 w-3 h-3 text-[#f85149] flex-shrink-0" title={tab.errorMessage} />
                    )}
                    {tab.isLoading && (
                      <IconLoader2 className="ml-1 w-3 h-3 animate-spin text-[#58a6ff] flex-shrink-0" />
                    )}
                    {savingTabs.has(tab.id) && (
                      <div className="ml-1 flex items-center text-amber-500" title="იცავება...">
                        <IconLoader2 className="w-3 h-3 animate-spin" />
                        <span className="ml-1 text-xs">💾</span>
                      </div>
                    )}
                    {savedTabs.has(tab.id) && !savingTabs.has(tab.id) && (
                      <div className="ml-1 flex items-center" title="წარმატებით შენახულია!">
                        <span
                          className="text-green-400 text-sm animate-pulse"
                          style={{
                            textShadow: '0 0 8px rgba(34, 197, 94, 0.8)'
                          }}
                        >
                          ✓
                        </span>
                      </div>
                    )}
                    <button
                      className="ml-2 p-1 opacity-0 group-hover:opacity-100 hover:bg-[#21262d] rounded-sm transition-all flex-shrink-0"
                      onClick={(e) => closeTab(tab.id, e)}
                      title="Close tab"
                    >
                      <IconX className="w-3 h-3 text-[#7d8590] hover:text-[#e6edf3]" />
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Content */}
          <div className="flex-1 relative overflow-hidden bg-gray-50 dark:bg-gray-900">
            {activeTabContent ? (
              <>
                {/* Action Buttons */}
                {activeTabContent.content && !activeTabContent.isLoading && !activeTabContent.hasError && (
                  <div className="absolute top-4 right-4 z-10 flex space-x-2">
                    {activeTabContent.hasUnsavedChanges && (
                      <button
                        onClick={() => saveFileContent(activeTabContent.path, activeTabContent.content!)}
                        disabled={savingTabs.has(activeTabContent.id)}
                        className="p-2 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-md transition-all duration-200 flex items-center space-x-1 text-xs"
                        title="Save file (Ctrl+S)"
                      >
                        {savingTabs.has(activeTabContent.id) ? (
                          <>
                            <IconLoader2 className="w-4 h-4 animate-spin" />
                            <span>Saving...</span>
                          </>
                        ) : (
                          <>
                            <IconCheck className="w-4 h-4" />
                            <span>Save</span>
                          </>
                        )}
                      </button>
                    )}
                    <button
                      onClick={copyToClipboard}
                      className={classNames(
                        'p-2 rounded-md transition-all duration-200 flex items-center space-x-1 text-xs',
                        copiedToClipboard
                          ? 'bg-green-500 text-white'
                          : 'bg-gray-800 hover:bg-gray-700 text-gray-300 hover:text-white'
                      )}
                      title={copiedToClipboard ? 'Copied!' : 'Copy to clipboard'}
                    >
                      {copiedToClipboard ? (
                        <>
                          <IconCheck className="w-4 h-4" />
                          <span>Copied!</span>
                        </>
                      ) : (
                        <>
                          <IconCopy className="w-4 h-4" />
                          <span>Copy</span>
                        </>
                      )}
                    </button>
                  </div>
                )}

                {activeTabContent.isLoading ? (
                  <div className="flex items-center justify-center h-full">
                    <div className="flex items-center space-x-3">
                      <IconLoader2 className="w-5 h-5 animate-spin text-blue-500" />
                      <span className="text-gray-600 dark:text-gray-400">Loading file content...</span>
                    </div>
                  </div>
                ) : activeTabContent.hasError ? (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center space-y-4 max-w-md">
                      <IconAlertTriangle className="w-16 h-16 mx-auto text-red-400" />
                      <div>
                        <p className="text-lg font-medium mb-1 text-red-600 dark:text-red-400">Unable to load file content</p>
                        <p className="text-sm text-gray-500 dark:text-gray-400 leading-relaxed">
                          {activeTabContent.errorMessage || 'File may be empty, corrupted, or inaccessible'}
                        </p>
                        <p className="text-xs text-gray-400 mt-2">
                          File: {activeTabContent.path}
                        </p>
                      </div>
                      <div className="flex flex-col space-y-2">
                        <button
                          onClick={() => openFile(activeTabContent.path, activeTabContent.name)}
                          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                        >
                          Try Again
                        </button>
                        <button
                          onClick={() => closeTab(activeTabContent.id)}
                          className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-sm"
                        >
                          Close Tab
                        </button>
                      </div>
                    </div>
                  </div>
                ) : activeTabContent.content ? (
                  <div className="h-full">
                    <Editor
                      height="100%"
                      language={activeTabContent.language}
                      value={activeTabContent.formattedContent || activeTabContent.content}
                      onChange={handleEditorChange}
                      onMount={handleEditorDidMount}
                      theme="replit-dark"
                      options={{
                        readOnly: false,
                        domReadOnly: false,
                        contextmenu: true,
                        wordWrap: 'on',
                        minimap: { enabled: false },
                        scrollBeyondLastLine: false,
                        fontSize: 14,
                        fontFamily: '"SF Mono", Monaco, Inconsolata, "Roboto Mono", "Source Code Pro", monospace',
                        fontWeight: '400',
                        lineHeight: 1.5,
                        letterSpacing: 0.2,
                        padding: { top: 20, bottom: 20 },
                        lineNumbers: 'on',
                        lineNumbersMinChars: 4,
                        automaticLayout: true,
                        theme: 'replit-dark'
                      }}
                    />
                  </div>
                ) : (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center space-y-4">
                      <IconFile className="w-16 h-16 mx-auto text-gray-300" />
                      <div>
                        <p className="text-lg font-medium mb-1">File is empty</p>
                        <p className="text-sm text-gray-400">
                          This file appears to be empty or contains no readable content
                        </p>
                      </div>
                    </div>
                  </div>
                )}
              </>
            ) : (
              <div className="flex items-center justify-center h-full text-gray-500">
                <div className="text-center space-y-4">
                  <IconFile className="w-16 h-16 mx-auto text-gray-300" />
                  <div>
                    <p className="text-lg font-medium mb-1">Select a file to view</p>
                    <p className="text-sm text-gray-400">
                      Click on any file in the tree to open it with syntax highlighting
                    </p>
                  </div>
                  {searchQuery && (
                    <p className="text-xs text-gray-400">
                      Tip: Use Ctrl+P to quickly search for files
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Context Menu */}
      {contextMenu.visible && (
        <div
          className="fixed bg-[#161b22] border border-[#30363d] rounded-md shadow-lg py-1 z-50 min-w-32"
          style={{ left: contextMenu.x, top: contextMenu.y }}
        >
          <button className="w-full px-3 py-2 text-sm text-left hover:bg-[#21262d] text-[#e6edf3] flex items-center">
            <IconEdit className="w-4 h-4 mr-2" />
            Rename
          </button>
          <button className="w-full px-3 py-2 text-sm text-left hover:bg-[#21262d] text-[#e6edf3] flex items-center">
            <IconCopy className="w-4 h-4 mr-2" />
            Duplicate
          </button>
          {contextMenu.type === 'directory' && (
            <button className="w-full px-3 py-2 text-sm text-left hover:bg-[#21262d] text-[#e6edf3] flex items-center">
              <IconFile className="w-4 h-4 mr-2" />
              New File
            </button>
          )}
          <hr className="my-1 border-[#30363d]" />
          <button className="w-full px-3 py-2 text-sm text-left hover:bg-[#21262d] text-red-400 flex items-center">
            <IconTrash className="w-4 h-4 mr-2" />
            Delete
          </button>
        </div>
      )}

      {/* Hidden File Inputs */}
      <input
        ref={fileInputRef}
        type="file"
        multiple
        className="hidden"
        onChange={(e) => e.target.files && handleFileUpload(e.target.files)}
      />

      <input
        ref={folderInputRef}
        type="file"
        webkitdirectory=""
        multiple
        className="hidden"
        onChange={(e) => e.target.files && handleFileUpload(e.target.files)}
      />

      {/* New File/Folder Modal */}
      <NewFileModal
        isOpen={newFileModal.isOpen}
        type={newFileModal.type}
        parentPath={newFileModal.parentPath}
        onClose={() => setNewFileModal({ isOpen: false, type: 'file' })}
        onConfirm={(name) => createNewItem(name, newFileModal.type, newFileModal.parentPath)}
      />
    </div>
  );
};

export default React.memo(FileTree);