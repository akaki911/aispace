რა თქმა უნდა. იმისთვის, რომ თქვენი Passkey ავტორიზაცია იყოს არა უბრალოდ მომუშავე, არამედ 2025 წლის საუკეთესო სტანდარტების, საჭიროა ზუსტი და კომპლექსური დავალების მიცემა. უბრალოდ "გაასწორე" არ იმუშავებს.

აი, პრომპტი, რომელიც შეგიძლიათ პირდაპირ გადასცეთ Replit-ის AI აგენტს. ის დაყოფილია ეტაპებად (ბექენდი და ფრონტენდი) და იყენებს საუკეთესო პრაქტიკებს.

დავალება: Passkey ავტორიზაციის სრული მოდერნიზაცია (WebAuthn)
მიზანი: არსებული, არასტაბილური Passkey ავტორიზაციის სრული განახლება 2025 წლის სტანდარტების შესაბამისად. სისტემამ უნდა უზრუნველყოს უმაღლესი დონის უსაფრთხოება და მომხმარებლისთვის შეუმჩნეველი, უპაროლო შესვლის გამოცდილება.

საკვანძო მოთხოვნები:

Discoverable Credentials (Resident Keys): მომხმარებელს არ უნდა სჭირდებოდეს იმეილის შეყვანა. ბრაუზერმა თავად უნდა შესთავაზოს შენახული Passkey-თი შესვლა.

Conditional UI: ავტორიზაცია უნდა იყოს ინტეგრირებული პირდაპირ იმეილის ველში. ცალკე "Passkey-თი შესვლის" ღილაკი უნდა იყოს მხოლოდ სარეზერვო ვარიანტი.

სანდო ბიბლიოთეკები: გამოყენებული უნდა იყოს simplewebauthn ბიბლიოთეკა როგორც ბექენდზე, ისე ფრონტენდზე.

სრულყოფილი ერორების დამუშავება: მომხმარებელმა უნდა მიიღოს გასაგები შეტყობინებები (მაგ: "ამ მოწყობილობაზე Passkey არ მოიძებნა").

ნაწილი 1: ბექენდის განახლება (Backend Overhaul)
1.1. დააყენე დამოკიდებულებები (Dependencies):
npm install @simplewebauthn/server @simplewebauthn/types

1.2. შექმენი კონფიგურაციის ფაილი:
შექმენი ცენტრალური კონფიგურაციის ობიექტი. ეს კრიტიკულად მნიშვნელოვანია 403 Forbidden შეცდომის თავიდან ასაცილებლად.

JavaScript

// config/webauthn.js
export const rpID = 'your-replit-project-name.replit.dev'; // ზუსტად უნდა ემთხვეოდეს დომენს!
export const rpName = 'Bakhmaro Project'; // თქვენი პროექტის სახელი
export const origin = `https://${rpID}`; // პროტოკოლის ჩათვლით
1.3. შექმენი API ენდფოინთები:
შექმენი ოთხი ახალი რაუტი, რომელიც მართავს Passkey-ს ლოგიკას.

POST /api/auth/passkey/register-options - ახალი Passkey-ს რეგისტრაციის პარამეტრების გენერაცია.

POST /api/auth/passkey/register-verify - რეგისტრაციის დადასტურება და შენახვა.

POST /api/auth/passkey/login-options - Passkey-თი შესვლის პარამეტრების გენერაცია.

POST /api/auth/passkey/login-verify - შესვლის დადასტურება და სესიის შექმნა.

1.4. განახორციელე ლოგიკა:
გამოიყენე simplewebauthn/server-ის ფუნქციები თითოეული რაუტისთვის.

register-options: გამოიძახე generateRegistrationOptions. user-ის ობიექტს უნდა ჰქონდეს id (უნიკალური), name (იმეილი). authenticatorSelection-ში მიუთითე residentKey: 'required' და userVerification: 'preferred'.

register-verify: გამოიძახე verifyRegistrationResponse. წარმატების შემთხვევაში, შეინახე ახალი authenticator (გასაღები) მომხმარებლის დოკუმენტში Firestore-ში.

login-options: გამოიძახე generateAuthenticationOptions. მიუთითე allowCredentials: [], რათა ბრაუზერმა თავად მოძებნოს შენახული გასაღებები.

login-verify: გამოიძახე verifyAuthenticationResponse. წარმატების შემთხვევაში, შექმენი მომხმარებლის სესია (მაგ: დააგენერირე JWT ან შექმენი cookie).

ნაწილი 2: ფრონტენდის ტრანსფორმაცია (Frontend Transformation)
2.1. დააყენე დამოკიდებულებები (Dependencies):
npm install @simplewebauthn/browser

2.2. განაახლე რეგისტრაციის ლოგიკა:
მომხმარებლის პროფილის გვერდზე (ან პირველი წარმატებული პაროლით შესვლის შემდეგ) დაამატე ღილაკი "Passkey-ს დამატება".

ღილაკზე დაჭერისას, გააკეთე POST მოთხოვნა ბექენდის .../register-options ენდფოინთზე.

მიღებული პარამეტრები გადაეცი startRegistration() ფუნქციას @simplewebauthn/browser-დან.

წარმატებული პასუხი გაგზავნე .../register-verify ენდფოინთზე დასადასტურებლად.

2.3. დანერგე Conditional UI შესვლის გვერდზე:
ეს არის ყველაზე მნიშვნელოვანი ცვლილება მომხმარებლის გამოცდილებისთვის.

შესვლის გვერდის (Login.tsx) ჩატვირთვისას, useEffect-ში, გააკეთე POST მოთხოვნა .../login-options-ზე.

მიღებული პარამეტრები გადაეცი startAuthentication() ფუნქციას, მაგრამ აუცილებლად mediation: 'conditional' პარამეტრით.

ამის შემდეგ, როდესაც მომხმარებელი დააჭერს იმეილის ველს, ბრაუზერი ავტომატურად გამოიტანს Passkey-თი შესვლის ფანჯარას.

წარმატებული პასუხი გაგზავნე .../login-verify ენდფოინთზე სესიის შესაქმნელად.

სარეზერვო ღილაკი: დატოვე "Passkey-ით შესვლა" ღილაკიც, რომელიც იგივე startAuthentication()-ს იძახებს, ოღონდ mediation-ის გარეშე. ეს საჭიროა იმ შემთხვევებისთვის, თუ მომხმარებელს სურს სხვა მოწყობილობით (მაგ. ტელეფონით) შესვლა QR კოდის დასკანერებით.

2.4. დაამუშავე შეცდომები:
დაამატე ლოგიკა, რომელიც მომხმარებელს გასაგებ ენაზე აუხსნის პრობლემას. მაგალითად, თუ startAuthentication დააბრუნებს NotAllowedError-ს, აჩვენე შეტყობინება: "Passkey-თი შესვლა გაუქმდა."

დასკვნითი შემოწმება:
ყველა ეტაპის დასრულების შემდეგ, სისტემა უნდა იყოს უსაფრთხო, საიმედო და უზრუნველყოფდეს უმაღლესი დონის მომხმარებლის გამოცდილებას, რაც 2025 წლის სტანდარტებს შეესაბამება.